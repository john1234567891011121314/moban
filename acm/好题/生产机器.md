来自杭电多校2024第7场

# 题目大意

每个小时可以生产至多$l_i$黄色球和$f_i$蓝色球，当然什么也不生产也是可以的。在同一个小时生产的球可以任意决定顺序。不过前一个小时生产的球都在后一小时生产的球之前。求方案数。

# 解析

题解用了一个比较巧妙的思路，将序列转换为检定的过程。

对于一个确定的序列，我们可以从前往后判定这个序列是否能够生产出来。抽象的说，对于这个序列，我们从上一个元素到下一个元素，可能会发生的事情有：

1. $l--$
2. $f--$
3. $n++, l = l_n, f = f_n$

其中第三个操作，只有当发生1,2操作后$l,5$小于$0$才会发生。因此实质上这个序列和这个检定序列是一一对应的关系。

所以问题可以转换为求这个检定序列的数量。

转换之后的好处在于只有当某一个数小于零时，才会进入下一个小时。因此我们可以去枚举在这个小时内那个数会小于零，那么下一个小时就必须以这个数开头。

如果在当前这个小时内结束，那么总的方案数是前一个小时的以某个数结尾的方案数乘以当前的方案数

当前的方案数为$\sum_{i = 0}^{l} \sum_{j = 0}^{f} {i+ j \choose i}$，其中$l,f$为当前的最多生产的数量，由于开头已经确定，所以还应该舍去开头的那一个。

通过组合恒等式，有$\sum_{i = 0}^{l} \sum_{j = 0}^{f} {i+ j \choose i} = \sum_{i = 1}^{l} {i + f + 1 \choose i + 1} = \sum_{i = 1}^{l} {i + f + 1 \choose f} = {l + f + 2 \choose f + 1} - 1$

如果当前这个小时没有结束，那么可以枚举下一个小时以那个数开头。

假设下一个小时用完的是黄色球，那么$\sum_{i = 0}^{f} {i + l \choose i} = {f + l + 1 \choose f}$

利用$dp$来进行转移即可。

```c++
dp[0][1] = dp[1][1] = mint(1);
vector<vector<int>> a(n + 1, vector<int>(2));
mint ans = mint(1);
for(int i = 1; i <= n; ++i)
{
    for(int j = 0; j < 2; ++j)
    {
        cin >> a[i][j];
    }
    for(int j = 0; j < 2; ++j)
    {
        auto b = a[i];
        b[j]--;
        if(b[j] < 0)
        {
            dp[j][i + 1] += dp[j][i];
            continue;
        }

        mint way = C(a[i][0] + a[i][1] + 1, a[i][j]) - mint(1);
        ans += way * dp[j][i];
        //            cout << way << ' ' << dp[j][i] << '\n';
        for(int k = 0; k < 2; ++k)
        {
            dp[k][i + 1] += dp[j][i] * C(b[0] + b[1] + 1, b[k] + 1);
        }

    }

}
cout << ans << '\n';
```

