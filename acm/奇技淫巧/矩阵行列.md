## 将矩阵某一行或某一列加一最后模$k$为0

给定一个矩阵，每次将某一行或者某一列加一，求模$k$意义下该矩阵变成全0的最小代价。

### 分析

我们不妨假设$r_i$表示第$i$行的操作次数，$c_j$表示的$j$行的操作次数，那么我们要求的就是满足方程组$r_i+c_j +a_{i,j} \equiv 0 (\mod k)$ 的最小解。

因为我们有$n*m$的方程只有$n+m$的未知数，所以有很多方程是冗余的。

首先我们一定有存在$r_i$或者$c_i$为$0$。

不妨假设两者都大于0。

对于$n \ge m $的情况，我们让所有的$r_i := r_i-1$，$c_i := c_i +1$，此时我们减少了$n-m$次操作，但是矩阵和之前一样。

对于$n < m$ 的情况，同理可得。

于是至少有一个$r_i$或者$c_I$等于$0$l。

于是去枚举某一行某一列为$0$的情况。

假设我们让$r_i=0$那么对于列来说$c_j=-a_{i,j}(\mod k)$。

然后我们就可以求出所有的$r_i$和$c_i$了。

代码如下

```c++
bool check()
{
    for(int i = 1; i <= n; ++i)
    {
        for(int j= 1; j <= n; ++j)
        {
            if((a[1][1] + a[i][j]) % k != (a[1][j] + a[i][1]) % k) return 0;
        }
    }
}

ll calc1(int x)
{
    ll ans = 0;
    ll c_1 = (k - a[x][1]) % k;
    for(int i = 1; i <= n; ++i) ans += (k - a[x][i]) % k;
    for(int i = 1; i <= m; ++i) ans += (- c_1 - a[i][1] + 2 * k) % k;
    return ans;
}

ll calc2(int x)
{
    ll ans = 0;
    ll r_1 = (k - a[1][x]) % k;
    for(int i = 1; i <= m; ++i) ans += (k - a[i][x]) % k;
    for(int i = 1; i <= n; ++i) ans += (- r_1 - a[1][i] + 2 * k) % k;
    return ans;
}
```

### 对于零一矩阵来说，翻转操作等价于加一操作