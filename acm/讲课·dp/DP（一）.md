# DP（一）

这部分内容应该相对比较简单，大家可能在之前刷题的时候也碰到过写过，对这些东西还是比较会的。在讲述时我会比较注意dp的一些小技巧，一些我个人的思考方式，而不是说题目本身。

在思考dp问题时，最麻烦的是设计dp状态，接下来将挑几道模板题说明一下在设计这些状态时，可能的思考方向，希望这有助于你们形成自己解决dp的方法。

## 区间dp

首先我们来讲讲区间dp，区间dp往往能够将问题转换为两两合并的形式。然后在转移的时候枚举分界点转移，从而得到更大规模问题的最优解。

一般我们都用dp【l】【r】来表示这个区间的状态，有时候可能多加几维。

### 板题

#### 校oj 1181 石子合并

我们首先从区间dp的经典模板题开始。

预留几分钟思考时间，可以补充一下例子。

在实际写的时候，我们可以将区间长度作为第一层循环。这样我们在计算大区间的答案之前，就可以把小区间的答案求出来了。

当然也可以用记忆化的方法去做。

#### 校oj 3824 环形石子合并

破环成链，div3

#### hdu7277[Mr. Liang play Card Game](https://vjudge.net.cn/contest/642626#problem/C)

一场杭电多校的题。

预留几分钟思考时间

回顾一下石子合并的做法，我们会发现石子合并我们只需要考虑合并完之后最小的代价就行了。

但是这一题不一样，这一题还需要考虑牌的类型和牌的等级，注意到这里这两个数都不太大，因此考虑将这两个也加入到状态里。

因此设$dp[l][r][type][lv]$，表示这个区间$[l,r]$最后剩下的牌的类型为$type$，等级为$lv$的时候的最大值，特别的，我们可以设$dp[l][r][0][0]$，表示这段区间所有牌打出去所能获得的最大贡献。

然后进行分类讨论就可以了。



### 补充：

杭电多校里有很多区间dp，如果想要更进一步的练习话也可以去看看。

## 状压dp

状压dp一般用来解决np问题，也就是只能考虑枚举每一个子集的情况。

关于状压dp，主要就是用二进制表示状态。

一般来说n只有20，在某些题，比如最近的多校里，需要把状态减掉，将一部分根本不会出现的状态优化掉，最后再进行转移。

### 板题

#### TSP问题 吃奶酪

状压dp最经典的用法就是解决这类没有办法用贪心或者什么办法解决的题目。

针对这道题目，首先我得知道我走过了那些点，其次我得知道我现在在那个位置，然后我们就可以根据这两个状态设计dp进行转移。

（适当画图说明）

然后这里，我们可以做一个扩展，如果我们以后需要在有向无环图上求一个点能否到达其他点，我们有什么办法吗。这里不能使用并查集，和这里的状态类似，可以考虑使用二进制数来表示可达性。

#### 数组的最大与和

这道题可能大家之前都写过类似的题目，这里就简单过一下。

关于这道题，一个可以了解的trick是你可以用状压去枚举最优的排列。

画图（）

其实和上一个TSP问题是一样的，TSP问题也是用枚举排列。

#### 看守

这道题虽然不是传统的状压，但是因为也体现了状压的思想，因此也放出来给大家想一想。

叙述曼哈顿距离。

预留思考时间。

首先大家肯定都会一个$n^2k$的算法，就我直接可以枚举两个点，但是这里n还是比较大的，这样不太行。

但是这里有一个常见套路就是，我们可以把绝对值拆开，拆开之后就得到了一个max，然后对max处理。

转换成max之后，我们就有了比较好的性质，比如可以满足分配律，然后我们就可以把这个原先的绝对值转换为一堆东西求max的过程。

最后这题就结束了。

### 补充

状压dp目前来说是很少考比较板的题目。更多是和其他联合起来，比如可以和什么质因数分解联合起来，问你完全平方数的问题，又比如可能和sosdp，子集dp联合起来，在遇到的时候不太会单独出现，更多的时候就和看守这一题一样，作为状压的思想出现，但是可能不需要使用状压。

## 数位dp

### 板题

#### 数字计数

首先如果这个区间不大，那么我们可以对区间里每一个数进行处理。

其次我们发现比较难处理的点在于这个区间两边都给夹起来了，不好处理，一个比较常见的处理办法是把这个区间划分为[1,a]和[1,b]两个情况，然后对于数字a，我们再单独考虑。

对与[1,a]或者[1,b]，我们发现这两个区别不大，都是求前n个数里，每个数码出现多少次。

然后我们就可以考虑怎么去处理这个东西。

一个思考方法是，你可以把整个数字分解为三部分，第一部分是前缀，固定的数，第二部分是是变小的数，第三部分是任意的数。（画图）

举个例子，对于123410这个数，假设我们固定了123这个前缀，那么我们就可以枚举4这一位变成0,1,2,3,这几种情况，这样子后面就可以是任意的情况。然后这后面的部分我们就可以使用记忆化的方法去解决，从而控制复杂度在数位上。具体来说，我们可以写一个dp数组表示最后i位任意的情况下，每个数码出现的次数，那么我们记忆化搜索实质就是在做这样一个过程。

当然这样子还有一些细节需要考虑，比如根据写法的不一样，我们实际解决的是[1,a-1]或者[1,a]的部分，对于b这个数字我们没有考虑，因此b还需要考虑一下，这个部分的处理，一个是可以写一个大数加1或者大数减1的算法，另外一个就是写额外的check去检验这个数是否可行。

#### 不要62

这是oj上比较经典的题，不过这里还是稍微讲一下。

这个问题和上一个的区别在于，这个问题多了一些限制，第一个限制是不能出现4，第二个限制是不能有连续的62，第一个好解决，枚举的时候忽视4就行，第二个限制相对麻烦一些，我们需要记录上一位是否为6，如果不为6，那么其实本质是一种情况，也就是对当前位没有限制，除了不能选4，如果上一位是6，那么当前位就是不能2。类似于上一题，我们可以设计出这样一个dp状态，$dp[i][j]$表示后面i位任意且第i+1位是否为6的数有多少。

#### 数位的关系

这题比较难，先给大家几分钟时间思考一下。

这道题就是就是给大家看看，比较难比较单一的数位dp大概是什么档次。

基本上难的数位dp就是这个难度，在金牌题里也是属于难的部分，像这种题可能就需要一个人占用大量机时去写，完了还不一定能写得出来，但是这种题放练习里，花5个小时去写，我觉得大家应该还是能写出来的。但是怎么样去占用最少的机时去写，在赛时去分配时间也是很重要的一个策略。你看这种题赛时一个人想写出来还是很困难的，还有一些模拟题，谁都会写，但是很花时间。

哪怕金牌题，这种数位dp你也能一眼看出来，还是比较板的一题。

那么我们设状态也是和前面思考的一样，假设前面已经固定，我们统计数量的时候应该怎么统计。首先我们肯定要知道当前已经选了几位，其次要知道最后一个选的数是多少，如果我们当前位想选3，那我们得知道3前面那个数和3之间的关系，或者3就是第一个选的，然后就自然而然的推出这个状态，但是这样还不行，我们能发现如果前面都是零的情况下，我们不能选择这个零，因为前导零按我们的想法应该是没有的，所以我们还需要一个状态判断是否有前导零。

这种题看上去和我们之前的好像也没什么区别，但是这题确实金牌题，就是因为细节很多，需要花很多时间去debug.

这道题我没有放在链接里，因为比较难，当然大家听完之后觉得直接会写也可以去杭电oj上写。	

### 补充





