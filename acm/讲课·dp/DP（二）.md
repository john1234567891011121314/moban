概率正推，期望逆推

一般概率期望经常放一起，这里也放一起讲。

大家可能不太熟悉的是贝叶斯公式，这个公式实质是条件概率和全概率公式的混合。



# 概率dp

## Bag of mice

留两分钟思考一下。

因为我们其实只考虑公主的胜率，不需要考虑龙的胜率。因此我们可以考虑$dp[i][j]$表示回合开始前，轮到公主时，有$i$只白鼠和$j$只黑鼠的情况下，能够获胜的概率。那么我们要求的就是$dp[w][b]$。

## Jon and Orbs

留两分钟看题。

这道题首先你能观察到二分性质，天数越多，那么概率就越高。

那么问题就转换为了第$i$天产生$k$种龙晶的概率，然后我们就可以设出状态$dp[i][j]$表示第$i$天产生$j$个龙晶的概率。



有后效性

# 期望dp

**期望的线性性**是我们考虑期望$dp$时相当重要的点。另外就是全期望公式，和全概率差不多，做的时候想办法套一下公式就行。这个公式直观理解的话，比如这里有一份工作，要么甲做，要么乙做，然后你就可以写出总的期望，也就是甲做的概率乘以甲做完的期望时间，加上乙做的概率乘以乙做完的期望时间。

## Collecting Bugs

留两分钟看题

你会发现这个东西其实和刚才的龙晶没有什么区别，我们的dp状态也大差不差，但是这次我们就不用维护天数，$dp[i][j]$表示发现$i$个不同的bug，同时属于$j$个子系统的期望天数。当然因为我们期望dp需要倒着来，因此这个状态就设为到达我们想要状态的期望天数。

为什么我们要倒着来呢，以这道题为例，这里就有可能状态不发生变化，但是我们在推导时没有把这个东西考虑进去，$[i][j]$状态经过一次变化之后，还是这个状态。如果我们倒着来就不会有这个问题。（画图）

## Chiitoitsu

已知牌堆一共有34种类型，每种类型的牌四张

在开局会发给你13张牌，（**保证**每种类型的牌的数量小于等于2)，以此进行游戏

在每一回合，先从牌库抽一张牌，若此时十四张手牌为（7种不同的类型，每种各两张）则算作胜利，结束游戏。否则就从十四张牌中选择一张放入弃牌堆（不放回的意思）

一共T组样例，每次给你起始手牌，询问在**最优策略的情况下**的获胜的期望次数。

留两分钟看题。

首先思考什么是最优策略

如果我当前拿到的牌，我手中已经有了2张，那么我们就直接丢弃这张牌

如果我当前已经有一张，那么我们丢弃另外的只有一张的牌

如果我当前没有，那么直接把这张牌丢了

为什么呢，首先我一开始手上一定有单牌，那么最后我们肯定是和一开始留下的牌进行匹配，不然如果我们先前把某个类型的牌丢了，那么后面我们就不可能再拿这个类型的牌，因为牌库里这种牌的数量已经小于$3$了，比一开始就有的牌抽到的概率低。

于是我们发现每次我只需要关心牌库里还有几张牌，以及我当前有几张单牌。

于是设$dp[i][j]$表示牌库里还有$j$张牌，手上有$i$张单牌，然后到达全匹配的期望次数。

容易发现$dp[1][3]=1$。即当我手上有只有一张单牌，同时牌库里还有三张牌时，我们怎么样都可以抽出一个

和其匹配的牌。

同时我们有转移方程
$$
dp[i][j]=1+\frac{3*i}{j}dp[i-2][j-1]+\frac{j-3*i}{j}dp[i][j-1]
$$
这里$-2$是因为还有一张牌被我们丢了

当$i$等于1时，我们有
$$
dp[i][j]=1+\frac{j-3*i}{j}dp[i][j-1]
$$
这是因为只有我们没抽到想要的牌，我们才需要继续抽

###### 题意

一个长度为$n$的序列，每次操纵随机选取两个下标，然后将这两个下标对应的数进行交换，问$m$次操作后每一位和一开始不同的个数的期望

###### 分析

一道很好的期望题，虽然赛时尝试打表并没有找到什么规律

我们计$f_m$表示操作%$m$次后，$a_0=0$的概率。

因为每一位其实是等价的，我们计算时可以

$E(\sum X_i) =\sum E(X_i)=n*E(X_0)=n*f_m$

其中$E(X_i)$表示第$i$位和一开始一样的期望

因此只需要计算$f_m$即可

首先第$m$次和原来相同，来自于前一次和原来相同，然后操作一次不变，或者前一次和原来不同，但是操作完后回到原位置

原来相同，操作不变，可能是两次交换的下标都是$0$，或者都不是$0$

原来不同，那么只有两种情况回到原位置

$f_m= \frac{1+(n-1)^2}{n^2} f_{m-1} + \frac{2}{n^2} (1-f_{m-1})$

化简得到$f_m=\frac{2}{n^2}+\frac{n-2}{n}f_{m-1}$

然后就可以用矩阵快速幂之类的方法维护了。

###### 题意

若干个宝箱，宝箱里有东西的概率是$p$，求最后$n$次中至少有$k$个宝箱期望次数

###### 分析

这题$n$，$k$很小，只有$6$

考虑枚举最后$n$位的状态，我们有
$$
dp[z_0z_1z_2z_3z_4z_5]=1+p*dp[1z_0z_1z_2z_3z_4]+(1-p)*dp[0z_0z_1z_2z_3z_4]
$$
然后高斯消元即可





随机游走

# 子集dp



# 单调栈优化dp

优化条件：

对于形如$f[i]=max_{L[i] \leq j \leq R[i]} (f[j]+w[i])$的式子进行优化

##### 烽火传递

###### 题意

在某两个城市之间有 n 座烽火台，每个烽火台发出信号都有一定的代价。

为了使情报准确传递，在连续 m 个烽火台中至少要有一个发出信号。

首先有$dp$转移式，$dp[i]=min_{i-m+1 \leq j \leq i-1}(dp[j]+a[i])$

然后套板子即可

##### The Great Wall II

###### 题意

将n个数分成m段，每一段的代价是这一段数的最大值，求$m=1 \cdots n$时的最小代价

###### 分析

朴素写法即枚举前$i$个数，分成$j$段，然后考虑第$j+1$段是从那里开始到$i+1$

考虑优化，我们发现状态可以分为$a_i$作为最后一段贡献或者不是最后一段最大值

我们记$dp[i][j]$为前$i$个数分成$j$段的代价，那么就有$dp[i][j]=min_{ pos \leq p \leq i-1}(dp[p][j-1]+a[i])$，表示$a_i$作为最后一段最大值，然后$pos$表示$a[pos-1] \ge  a[i]$的最大的值，即上一个比$a_i$大的位置的下一位

如果不是最大值，那就有$dp[i][j]=dp[pos-1][j]$，这时将最后一段区间挂到$pos-1$的第$j$段上，那么$a_i$一定不是这一段的代价

首先单调栈维护上一个$pos$的值，$dp[i][j]$不具有单调性，因此我们考虑在为维护$pos$的时候顺便也维护对应的$dp$值，即栈内两个相邻元素的对应的下标的$min ~dp$。