## 多项式
### 多项式概述

#### 常用多项式

|      名称       |                        公式                         |      方法       |       复杂度        |
| :-------------: | :-------------------------------------------------: | :-------------: | :-----------------: |
| 多项式乘法/卷积 |                   $F(x)=A(x)B(x)$                   |     NTT/FFT     |     $O(nlogn)$      |
|   多项式求逆    |     $B(x)\equiv2B_1(x)-B_1^2(x)A(x)(~mod~~x^n)$     | 分治+多项式乘法 |     $O(nlogn)$      |
|   多项式除法    | $A^R(x)B^{R^{-1}}(x)\equiv D^R(x)(~mod~~x^{n-m+1})$ |   多项式求逆    |     $O(nlogn)$      |
|   多项式取模    |                $P(x)=A(X)-D(X)B(X)$                 |   多项式乘法    |     $O(nlogn)$      |
|   多项式求导    |          $F'(x)=\sum_{i=1}^n ia_ix^{i-1}$           |       ---       |       $O(n)$        |
|      积分       |  $\int{F(x)}dx=\sum_{i=1}^n\frac{a_ix^{i+1}}{i+1}$  |       ---       |       $O(n)$        |
|      开根       |     $B(x)\equiv \frac{B_1^2(x)+A(x)}{2B_1(x)}$      | 分治+多项式求逆 |     $O(nlogn)$      |
|       ln        |           $ln(F(x))=\int{F'(x)F^{-1}(x)}$           |   多项式求逆    | $O(nlogn)$ 常数巨大 |
|       exp       |  $F(x) \equiv F_0(x)(1-ln F_0(x)+A(x))(~mod~~x^n)$  |    多项式ln     | $O(nlogn)$ 常数巨大 |

#### 关于limit,L,RR[N]

```c++
for(limit = 1, L = 0; limit <= (n + m) * 2; limit <<= 1) L ++ ;
for(int i = 0; i < limit; ++ i) 
   RR[i] = (RR[i >> 1] >> 1) | ((i & 1) << (L - 1));

```

#### 牛顿迭代

先随便选一个点，比如$x_0$，求函数上这个点的切线，求出这个切线的零点$x_0-\frac{f(x_0)}{f'(x_0)}$

将这个点作为新的点继续迭代，就会收敛。

在多项式应用上，只需将点理解成函数即可。

$G(x)=G_0(x)-\frac{F(G_0(x))}{F'(G_0(x))}$

也就是$F(G(X)) \equiv 0 (\mod x^n)$

#### 常用多项式展开式

$e^x = 1 + x + \frac{x^2}{2!} + \dots + \frac{x^n}{n!}$

$(a+b)^n = \sum C_n^i * a ^ i * b ^{n - i}$

$\frac{1}{1-x} = 1 + x + x ^ 2 + \dots + x ^ n$

$\frac{1}{(1-x)^n} = \sum_ {k = 0} (-1)^ k *C_{n + k - 1}^{k} * x ^ k$ 



#### 反演定理

$[x^n] F(x)^k = \frac{k}{n}[x^{n - k}](\frac{x}{G(x)})^n$

其中，$F(x)$与$G(x)$互为反函数且满足$[x^0]F(x)=[x^0]G(x)=0$以及$[x^1]F(x) \neq 0 ~ , [x^1] G(x) \neq 0$

此外，对于任意幂级数$H(x)$来说，有以下柿子

$[x^n] H(F(x)) = \frac{1}{n}[x^{n - 1}]H'(x)(\frac{x}{G(x)})^n$

$tips:ABC345$的$G$是其应用

#### 卷积的性质

交换律
$$
f~*~g~=g~*~f
$$
结合律
$$
(f~*~g)~*~h~=~f~*~(g~*~h)
$$



#### 大部分操作

#### note

1. **0次项，1次项，。。。**
2. **N的大小至少为1<<t**
3. **记得init()**
4. **对于大数幂次，要注意乘回来的幂次对$\phi(p)$​​取模，针对ppow**
5. **多项式开方如果第一项不是1，可以用BSGS来求这一项对应的二次剩余**
6. tt为19时会占用86MB内存
7. 如果mle了，tt又不能小，那么可以如下所示进行修改
8. 1e9+7的原根为5

   ```c++
   int deer[2][tt];
   //init()部分
   for(int p = 1; p <= t; ++ p) {
       deer[0][p] = qpow(inv_G, (mod - 1) / (1 << p));
       deer[1][p] = qpow(G, (mod - 1) / (1 << p));
   //     int buf1 = qpow(G, (mod - 1) / (1 << p));
   //     int buf0 = qpow(inv_G, (mod - 1) / (1 << p));
   //     deer[0][p][0] = deer[1][p][0] = 1;
   //     for(int i = 1; i < (1 << p); ++ i) {
   //         deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆
   //         deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod;
   //     }
   }
   //NTT部分
   for(int mid = 2, j = 1; mid <= limit; mid <<= 1, ++ j) {
       int len = mid >> 1;
       int wn = deer[type][j];
       int wp = 1;
       for(int pos = 0; pos < limit; pos += mid) {
   //                auto wn = deer[type][j].begin();
           wp = 1;
           for(int i = pos, p = 0; i < pos + len; ++ i, ++ p) {
               int tmp = 1ll * wp * A[i + len] % mod;
               // cerr << p << ' ' << wp << ' ' << deer[type][j][p] << ' ' << wn << '\n';
               wp = 1ll * wp * wn % mod;
               // int tmp = 1ll * deer[type][j][p] * A[i + len] % mod;
               A[i + len] = ck(A[i] - tmp + mod);
               A[i] = ck(A[i] + tmp);
           }
       }
   }
   ```

   

```c++

namespace Poly
{
    #define mul(x, y) (1ll * x * y >= mod ? 1ll * x * y % mod : 1ll * x * y)
    #define minus(x, y) (1ll * x - y < 0 ? 1ll * x - y + mod : 1ll * x - y)
    #define plus(x, y) (1ll * x + y >= mod ? 1ll * x + y - mod : 1ll * x + y)//上面其实没用到
    #define ck(x) (x >= mod ? x - mod : x)//取模运算太慢了

    typedef vector<int> poly;
    const int G = 3;//根据具体的模数而定，原根可不一定不一样！！！
    //一般模数的原根为 2 3 5 7 10 6
    const int inv_G = qpow(G, mod - 2),tt = 22;
    int deer[2][tt][(1 << tt)];
    vector<int>RR(1 << (tt + 1), 0),inv(1 << tt, 0);
    
    void init(const int t) {//预处理出来NTT里需要的w和wn，砍掉了一个log的时间
    	assert(t < tt);//一定要注意！！ 
        for(int p = 1; p <= t; ++ p) {
            int buf1 = qpow(G, (mod - 1) / (1 << p));
            int buf0 = qpow(inv_G, (mod - 1) / (1 << p));
            deer[0][p][0] = deer[1][p][0] = 1;
            for(int i = 1; i < (1 << p); ++ i) {
                deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆
                deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod;
            }
        }
        inv[1] = 1;
        for(int i = 2; i <= (1 << t); ++ i)
            inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod;
    }

    int NTT_init(int n) {//快速数论变换预处理
        int limit = 1, L = 0;
        while(limit <= n) limit <<= 1, L ++ ;
        assert(L < tt);
        assert(limit < 1 << (tt + 1));
        for(int i = 0; i < limit; ++ i)
            RR[i] = (RR[i >> 1] >> 1) | ((i & 1) << (L - 1));
        return limit;
    }

    void NTT(poly &A, bool type, int limit) {//快速数论变换
        A.resize(limit);
        for(int i = 0; i < limit; ++ i)
            if(i < RR[i])
                swap(A[i], A[RR[i]]);
        for(int mid = 2, j = 1; mid <= limit; mid <<= 1, ++ j) {
            int len = mid >> 1;
            for(int pos = 0; pos < limit; pos += mid) {
//                auto wn = deer[type][j].begin();
                for(int i = pos, p = 0; i < pos + len; ++ i, ++ p) {
                    int tmp = 1ll * deer[type][j][p] * A[i + len] % mod;
                    A[i + len] = ck(A[i] - tmp + mod);
                    A[i] = ck(A[i] + tmp);
                }
            }
        }
        if(type == 0) {
            for(int i = 0; i < limit; ++ i)
                A[i] = 1ll * A[i] * inv[limit] % mod;
        }
    }

    poly poly_mul(poly A, poly B) {//多项式乘法
        int deg = A.size() + B.size() - 1;
        int limit = NTT_init(deg);
        poly C(limit);
        NTT(A, 1, limit);
        NTT(B, 1, limit);
        for(int i = 0; i < limit; ++ i)
            C[i] = 1ll * A[i] * B[i] % mod;
        NTT(C, 0, limit);
        C.resize(deg);
        return C;
    }

    poly poly_inv(poly &f, int deg) {//多项式求逆 deg<f.size()
        if(deg == 1)
            return poly(1, qpow(f[0], mod - 2));

        poly A(f.begin(), f.begin() + deg);
        poly B = poly_inv(f, (deg + 1) >> 1);
        int limit = NTT_init(deg << 1);
        NTT(A, 1, limit), NTT(B, 1, limit);
        for(int i = 0; i < limit; ++ i)
            A[i] = B[i] * (2 - 1ll * A[i] * B[i] % mod + mod) % mod;
        NTT(A, 0, limit);
        A.resize(deg);
        return A;
    }

    poly poly_dev(poly f) {//多项式求导
        int n = f.size();
        for(int i = 1; i < n; ++ i) f[i - 1] = 1ll * f[i] * i % mod;
        if(n > 1)f.resize(n - 1);
		else f[0] = 0;
        return f.resize(n - 1), f;//求导整体左移，第0项不要 
    }

    poly poly_idev(poly f) {//多项式求积分
        int n = f.size();
        for(int i = n - 1; i ; -- i) f[i] = 1ll * f[i - 1] * inv[i] % mod;
        return f[0] = 0, f;//积分整体右移，第0项默认为0 
    }

    poly poly_ln(poly f, int deg) {//多项式求对数，第一项为1 
        poly A = poly_idev(poly_mul(poly_dev(f), poly_inv(f, deg)));
        return A.resize(deg), A;
    }

    poly poly_exp(poly &f, int deg) {//多项式求指数，第一项为0 
        if(deg == 1)
            return poly(1, 1);

        poly B = poly_exp(f, (deg + 1) >> 1);
        B.resize(deg);
        poly lnB = poly_ln(B, deg);
        for(int i = 0; i < deg; ++ i)
            lnB[i] = ck(f[i] - lnB[i] + mod);

        int limit = NTT_init(deg << 1);//n -> n^2
        NTT(B, 1, limit), NTT(lnB, 1, limit);
        for(int i = 0; i < limit; ++ i)
            B[i] = 1ll * B[i] * (1 + lnB[i]) % mod;
        NTT(B, 0, limit);
        B.resize(deg);
        return B;
    }

    poly poly_sqrt(poly &f, int deg) {//多项式开方,第一项是1 
        if(deg == 1) return poly(1, 1);
        poly A(f.begin(), f.begin() + deg);
        poly B = poly_sqrt(f, (deg + 1) >> 1);
        poly IB = poly_inv(B, deg);
        int limit = NTT_init(deg << 1);
        NTT(A, 1, limit), NTT(IB, 1, limit);
        for(int i = 0; i < limit; ++ i)
            A[i] = 1ll * A[i] * IB[i] % mod;
        NTT(A, 0, limit);
        for(int i =0; i < deg; ++ i)
            A[i] = 1ll * (A[i] + B[i]) * inv[2] % mod;
        A.resize(deg);
        return A;
    }

    poly poly_pow(poly f, int k) {//多项式快速幂,第一项得是1
        f = poly_ln(f, f.size());
        for(auto &x : f) x = 1ll * x * k % mod;
        return poly_exp(f, f.size());
    }
	
    poly poly_ksm(poly f, int k) {//多项式快速幂,适用于初始只有几项，同时所有项都需要的情况,会比上面那个快一点 
    	poly res(1, 1);
		while(k){
			if(k & 1)res = poly_mul(res, f);
			f = poly_mul(f, f);
			k >>= 1;
		} 
        return res;
	}
    
    poly poly_ppow(poly f, int k, int k2)	//多项式快速幂,允许前几项为0,k2是大数幂取模后的结果 
	{
		poly g;int m;int invg_0 = 0, qg_0 = 0;
		for(m = 0; m < f.size(); ++m)
		{
			if(f[m] != 0)
			{
				invg_0 = qpow(f[m], mod - 2);
				qg_0 = qpow(f[m], k2);
				for(int i = m; i < f.size(); ++i)
				{
					int x = 1ll * f[i] * invg_0 % mod;
					g.push_back(x);
				}
				break;
			} 
		}
		fill(f.begin(), f.end(), 0);
		if(1ll * k * m >= f.size())
		{
			return f;
		}
        
		g = poly_ln(g, g.size());
		for(auto &x : g) x = 1ll * x * k % mod;
		g = poly_exp(g, g.size());
		
		for(int i = k * m, j = 0; i < f.size(); ++i, ++j)//注意起点
		{
			f[i] = 1ll * g[j] * qg_0 % mod;
		}
		return f;
	} 
    
    poly operator / (poly A,poly B){
        reverse(A.begin(),A.end());
        reverse(B.begin(),B.end());
        int n = A.size(), m = B.size();
        A.resize(n - m + 1);
        B.resize(n - m + 1);
        B = poly_mul(poly_inv(B, n - m + 1), A);
		B.resize(n - m + 1);
		reverse(B.begin(), B.end());
        return B;
    }
    poly operator % (poly A,poly B){
		int n = A.size(), m = B.size();
		B = poly_mul(B, A / B);
		B.resize(m);
		for(int i = 0; i < m; ++i)B[i] = minus(A[i] , B[i]);//做差取模 
        return B;
    }
    const int img = 86583718;
    poly poly_cos(poly f, int deg) {//多项式三角函数（cos）
        poly A(f.begin(), f.begin() + deg);
        poly B(deg), C(deg);
        for(int i = 0; i < deg; ++ i)
            A[i] = 1ll * A[i] * img % mod;

        B = poly_exp(A, deg);
        C = poly_inv(B, deg);
        int inv2 = qpow(2, mod - 2);
        for(int i = 0; i < deg; ++ i)
            A[i] = 1ll * (1ll * B[i] + C[i]) % mod * inv2 % mod;
        return A;
    }

    poly poly_sin(poly f, int deg) {//多项式三角函数（sin）
        poly A(f.begin(), f.begin() + deg);
        poly B(deg), C(deg);
        for(int i = 0; i < deg; ++ i)
            A[i] = 1ll * A[i] * img % mod;

        B = poly_exp(A, deg);
        C = poly_inv(B, deg);
        int inv2i = qpow(img << 1, mod - 2);
        for(int i = 0; i < deg; ++ i)
            A[i] = 1ll * (1ll * B[i] - C[i] + mod) % mod * inv2i % mod;
        return A;
    }

    poly poly_arcsin(poly f, int deg) {
        poly A(f.size()), B(f.size()), C(f.size());
        A = poly_dev(f);
        B = poly_mul(f, f);
        for(int i = 0; i < deg; ++ i)
            B[i] = minus(mod, B[i]);
        B[0] = plus(B[0], 1);
        C = poly_sqrt(B, deg);
        C = poly_inv(C, deg);
        C = poly_mul(A, C);
        C = poly_idev(C);
        return C;
    }

    poly poly_arctan(poly f, int deg) {
        poly A(f.size()), B(f.size()), C(f.size());
        A = poly_dev(f);
        B = poly_mul(f, f);
        B[0] = plus(B[0], 1);
        C = poly_inv(B, deg);
        C = poly_mul(A, C);
        C = poly_idev(C);
        return C;
    }
}

using Poly::poly;
using Poly::poly_arcsin;
using Poly::poly_arctan;

int n, m, x, k, type;
poly f, g;
char s[N];

int main()
{
    Poly::init(18);//2^21 = 2,097,152,根据题目数据多项式项数的大小自由调整，注意大小需要跟deer数组同步(21+1=22) 开到比需要大的的最小2的幂*2 如1e6应该是21，1e5可以开18

    read(n), read(type);

    for(int i = 0; i < n; ++ i)
        read(x), f.push_back(x);

    if(type == 0) g = poly_arcsin(f, n);
    else g = poly_arctan(f, n);

    for(int i = 0; i < n; ++ i)
        printf("%d ", g[i]);
    return 0;
}

```

#### 多项式多点求值&快速插值

多点求值等价于一个向量左乘范德蒙德矩阵

即
$$
V(a_0,a_1, \dots, a_{m-1})= \begin{bmatrix} 1 & a_0 & a_0^2  & \dots & a_0^{n - 1}\\ 1 & a_1 & a_1^2 & \cdots & a_1 ^{n - 1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & a_{m - 1} & a_{m - 1} ^ 2 & \cdots & a_{m - 1}^{n - 1} \end{bmatrix}
$$
右乘
$$
f = \begin{bmatrix} f_0 \\ f_1 \\ f_2 \\ \vdots \\ f_{n - 1} \end{bmatrix}
$$
将$V$矩阵转置后我们得到
$$
V^T(a_0,a_1, \dots, a_{m-1})= \begin{bmatrix} 1 & 1 & 1  & \dots & 1\\ a_0 & a_1 & a_2 & \cdots & a_{n - 1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ a_0^{n - 1} & a_1^{n - 1} & a_2^{n - 1} & \cdots & a_{m - 1}^{n - 1} \end{bmatrix}
$$
将这个东西右乘之后，第$p$行的形式为$\sum_{i = 0}^{n - 1} a_i^p * f_i$

实质上是在求$[x^p]\sum_{i = 0}^{n - 1}\frac{f_i}{1-a_i*x}$

然后我们可以通过分治来解决这个问题

而对于原矩阵来说，由于左乘乘法是线性变换，因此倒着做这个过程就可以实现转换。



```c++
using Poly::poly;
namespace CalcMutiPoint
{
    constexpr int N = 100000;
    using Poly::poly_mul;
    using Poly::poly_inv;
    using Poly::poly_dev;
    constexpr int NODE = N * 2;
    int limit = 0;
    poly Q[NODE], QR[NODE];
    // vector<poly> Q, QR;//仅多点求值不需要QR

    poly MulT(poly a,poly b) 
    {
        int n = a.size(), m = b.size(); 
        std::reverse(b.begin(),b.end()), b = poly_mul(a,b);
        for(int i = 0; i < n; ++i) a[i] = b[i + m - 1];
        return a;
    }
    void calc_init(const poly &a, int p, int l, int r)
    {
        if(l == r)
        {
            if(limit < p)
            {
                limit = p;
                Q.resize(p + 1);
                QR.resize(p + 1);
            }
            Q[p].resize(2);
            Q[p][0] = 1, Q[p][1] = mod - a[l]; //小心
            QR[p] = Q[p];
            reverse(QR[p].begin(), QR[p].end());
            return ;
        }
        int mid = (l + r) >> 1;
        calc_init(a, p << 1, l, mid);
        calc_init(a, p << 1 | 1, mid + 1, r);
        Q[p] = poly_mul(Q[p << 1], Q[p << 1 | 1]);
        QR[p] = Q[p];
        reverse(QR[p].begin(), QR[p].end());
        return ;
    }
    void MutiPoint(int p, int l, int r, poly F, poly &g)
    {
        F.resize(r - l + 1);
        if(l == r)
        {
            g[l] = F[0];
            return ;
        }
        int mid = (l + r) >> 1;
        MutiPoint(p << 1, l, mid, MulT(F, Q[p << 1 | 1]), g);
        MutiPoint(p << 1 | 1, mid + 1, r, MulT(F, Q[p << 1]), g);
    }
    poly calcMutiPoint(poly f, poly a, int n) //n = max(f.size(), a.size())
    {
        f.resize(n + 1), a.resize(n);
        calc_init(a, 1, 0, n - 1);
        poly res(n);
        MutiPoint(1, 0, n - 1, MulT(f, poly_inv(Q[1], n + 1)), res);
        return res;
    }

    //快速插值
    poly solve(const poly &a, const poly &res, int p, int l, int r)
    {
        if(l == r)
        {
            poly f(1);
            f[0] = 1ll * a[l] * qpow(res[l], mod - 2) % mod;
            return f;
        }
        int mid = (l + r) >> 1;
        poly fl = solve(a, res, p << 1, l, mid);
        poly fr = solve(a, res, p << 1 | 1, mid + 1, r);
        fl = poly_mul(fl, QR[p << 1 | 1]);
        fr = poly_mul(fr, QR[p << 1]);
        if(fl.size() < fr.size()) swap(fl, fr);
        for(int i = 0; i< fr.size(); ++i)
        {
            fl[i] = plus(fl[i], fr[i]);
        }
        return fl;
    }
    poly insert(const poly &a, const poly &b, int n) // f(a_i) = b_i, 总共n个，从0开始
    {
        calc_init(a, 1, 0, n - 1);
        poly f = poly_dev(QR[1]);
        poly res(n);
        MutiPoint(1, 0, n - 1, MulT(f, poly_inv(Q[1], n + 1)), res);
        return solve(b, res, 1, 0, n - 1);
    }

}
using CalcMutiPoint::insert;
using CalcMutiPoint::calcMutiPoint;

{
    int n, m; cin >> n >> m;
    n++;
    Poly::init(18);
    poly f(n);
    for(auto &x : f) cin >> x;
    poly a(m);
    for(auto &x : a) cin >> x;
    auto res = calcMutiPoint(f, a, max(n, m));
    for(int i = 0; i < m; ++i) cout << res[i] << '\n';
}
{
	Poly::init(18);
    int n; cin >> n;
    poly f(n), g(n);
    for(int i = 0; i < n; ++i) cin >> f[i] >> g[i];
    poly res = insert(f, g, n);
    res.resize(n);
    for(int i = 0; i < n; ++i) cout << res[i] << " \n"[i + 1 == n];
}
```

```c++
using Poly::poly;
using Poly::poly_mul;
poly operator * (const poly &a, const poly &b)
{
    return poly_mul(a, b);
}
poly operator + (const poly &a, const poly &b)
{
    if(a.size() > b.size())
    {
        poly r = a;
        for(int i = 0; i < b.size(); ++i)
        {
            r[i] = plus(r[i], b[i]);
        }
        return r;
    }
    else 
    {
        poly r = b;
        for(int i = 0; i < a.size(); ++i)
        {
            r[i] = plus(r[i], a[i]);
        }
        return r;
    }
}
vector<int> G[N];
int B[N];
int sz[N];
int son[N];
void dfs(int x, int p)
{
    sz[x] = 1;
    for(int y : G[x])
    {
        if(y == p) continue;
        dfs(y, x);
        sz[x] += sz[y];
        if(sz[y] > sz[son[x]]) son[x] = y;
    }
}
int qu[N];
poly f[N][2]; 
poly rA[N], rB[N];
poly clcA(int l, int r)
{
    if(l == r)
    {
        return f[qu[l]][0] + f[qu[l]][1];
    }
    int  mid = (l + r) >> 1;
    poly L = clcA(l, mid);
    poly R = clcA(mid + 1, r);
    return L * R;
}
poly clcB(int l, int r)
{
    if(l == r) return f[qu[l]][0];
    int mid = (l + r) >> 1;
    poly L = clcB(l, mid);
    poly R = clcB(mid + 1, r);
    return L * R;
}
struct matrix
{
    poly a[2][2];
    int n = 2;
    void init()
    {
        for(int i = 0; i < n; ++i) for(int j = 0; j < n; ++j) a[i][j] = {0};
    }
    friend matrix operator*(const matrix &lhs, const matrix &rhs)
    {
        matrix res; res.init();
        for(int i = 0; i < 2; ++i)
        {
            for(int k = 0; k < 2; ++k)
            {
                for(int j = 0; j < 2; ++j)
                {
                    res.a[i][j] = res.a[i][j] + lhs.a[i][k] * rhs.a[k][j];
                }
            }
        }
        return res;
    }
};
matrix clc(int l, int r)
{
    if(l == r)
    {
        matrix tmp;
        tmp.n = 2;
        tmp.a[0][0] = tmp.a[1][0] = rA[qu[l]];
        tmp.a[0][1] = rB[qu[l]];
        tmp.a[1][1] = {0};
        return tmp;
    }
    int mid = (l + r) >> 1;
    return clc(l, mid) * clc(mid + 1, r);
}
void DFS(int x, int p, int ck)
{
    if(son[x]) DFS(son[x], x, 0);
    for(int y : G[x])
    {
        if(y == son[x] || y == p) continue;
        DFS(y, x, 1);
    }
    poly rb(2, 0); rb[1] = B[x];
    poly ra(1, 1);
    int cnt = 0;
    for(int y : G[x])
    { 
        if(y == son[x] || y == p) continue;
        qu[++cnt] = y;
    }
    if(cnt)
    {
        ra = clcA(1, cnt);
        rb = clcB(1, cnt) * rb;
    }
    rA[x] = ra, rB[x] = rb;
    if(ck)
    {
        cnt = 0;
        for(int y = x; y; y = son[y]) qu[++cnt] = y;
        auto ret = clc(1, cnt); 
        f[x][0] = ret.a[0][0], f[x][1] = ret.a[0][1];
    }
}
void solve()
{
    Poly::init(18);
    int n, m; cin >> n >> m;
    for(int i = 1; i <= n; ++i) cin >> B[i];
    for(int i = 1; i < n; ++i)
    {
        int u, v; cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, 0); //重链剖分
    DFS(1, 0, 1);
    f[1][0] = f[1][0] + f[1][1];
    if(m < f[1][0].size()) cout << f[1][0][m];
    else cout << 0 << '\n';
}
```



#### 据说飞快的板子，但是长

```c++
namespace Poly
{
    constexpr int mod = 998244353, mxbit = 23;
    constexpr int G = 3, pool_siz = 1 << 23;
    //一般模数的原根为 2 3 5 7 10 6
    typedef long long ll;
    typedef unsigned long long ull;
    typedef unsigned int uint;
    typedef vector<int> vec;
    namespace math
    {
        inline int qpow(ll x, int y = mod - 2, int ans = 1)
        {
            for (; y; y >>= 1, x = x * x % mod)
                if (y & 1) ans = ans * x % mod;
            return ans;
        }
        inline constexpr int lg(int x)
        {
            return x == 0 ? x : 32 - __builtin_clz(x);
        }
        vector<int> __fac({1, 1}), __inv({1, 1}), __ifac({1, 1});
        inline void __init(const int& n)
        {
            if ((int)__fac.size() > n) return;
            int i = __fac.size();
            for (__fac.resize(n + 1), __inv.resize(n + 1), __ifac.resize(n + 1);
                 i <= n; i++)
            {
                __fac[i] = 1ll * __fac[i - 1] * i % mod;
                __inv[i] = 1ll * (mod - mod / i) * __inv[mod % i] % mod;
                __ifac[i] = 1ll * __ifac[i - 1] * __inv[i] % mod;
            }
        }
        inline int gfac(const int& x) { return __init(x), __fac[x]; }
        inline int ginv(const int& x) { return __init(x), __inv[x]; }
        inline int gifac(const int& x) { return __init(x), __ifac[x]; }
        inline int binom(const int& n, const int& m)
        {
            return n < m || m < 0
                       ? 0
                       : (ll)gfac(n) * gifac(m) % mod * gifac(n - m) % mod;
        }
        inline int gadd(int x, const int& y)
        {
            return (x += y) >= mod ? x - mod : x;
        }
        inline int gsub(int x, const int& y)
        {
            return (x -= y) < 0 ? x + mod : x;
        }
        inline ull reduce(const ull& x)
        {
            constexpr ull U = -(ull)mod / mod + 1;
            constexpr ull V =
                (((__uint128_t)(-(ull)mod % mod) << 64) + mod - 1) / mod;
            return x * U + (ull)((__uint128_t)x * V >> 64) + 1;
        }
        inline ull mul(const ull& x, const ull& y)
        {
            return x * y * (__uint128_t)mod >> 64;
        }
    }  // namespace math
    using namespace math;  // namespace math

    namespace convolution
    {
        vector<ull> Gp, IGp;
        vector<int> gp, igp;
        inline void extend(const int& n)
        {
            if (gp.empty()) gp = igp = {1}, Gp = IGp = {math::reduce(1)};
            if ((int)gp.size() < n)
            {
                int l = gp.size();
                gp.resize(n), igp.resize(n), Gp.resize(n), IGp.resize(n);
                for (; l < n; l <<= 1)
                {
                    const int w = qpow(G, (mod - 1) / l >> 2),
                              iw = math::qpow(w);
                    for (int i = 0; i < l; i++)
                        gp[i | l] = (ll)gp[i] * w % mod,
                               igp[i | l] = (ll)igp[i] * iw % mod,
                               Gp[i | l] = math::reduce((uint)gp[i | l]),
                               IGp[i | l] = math::reduce((uint)igp[i | l]);
                }
            }
        }
        inline void DFT(vector<int>& f)
        {
            const int n = f.size();
            extend(n);
            for (int l = n; l >>= 1;)
                for (int i = 0, t = 0; i < n; i += l << 1, t++)
                    for (int j = i, k = i | l; j < (i | l); j++, k++)
                    {
                        const int a = f[j], b = mul((uint)f[k], Gp[t]);
                        f[j] = gadd(a, b), f[k] = gsub(a, b);
                    }
        }
        inline void IDFT(vector<int>& f)
        {
            const int n = f.size();
            extend(n);
            const ull ml = reduce((uint)(mod - (mod - 1) / n));
            for (int i = 0; i < n; i++)
                f[i] = mul((uint)f[i], ml);
            for (int l = 1; l < n; l <<= 1)
                for (int i = 0, t = 0; i < n; i += l << 1, t++)
                    for (int j = i, k = i | l; j < (i | l); j++, k++)
                    {
                        const int a = f[j], b = f[k];
                        f[j] = gadd(a, b), f[k] = mul((uint)gsub(a, b), IGp[t]);
                    }
        }
    }  // namespace convolution
    using convolution::DFT;
    using convolution::IDFT;
    struct poly
    {
        vec f;
        poly(int len = 1, int same_val = 0) : f(len, same_val) {}
        poly(const vec& _f) : f(_f) {}
        poly(vec::const_iterator __first, vec::const_iterator __last)
            : poly(vec(__first, __last))
        {
        }

        inline vec::iterator begin() { return f.begin(); }
        inline vec::iterator end() { return f.end(); }
        inline const vec::const_iterator begin() const { return f.begin(); }
        inline const vec::const_iterator end() const { return f.end(); }
        inline void swap(poly& _f) { f.swap(_f.f); }
        inline int degree() const { return (int)f.size() - 1; }
        inline int size() const { return (int)f.size(); }
        inline poly& redegree(int x) { return f.resize(x + 1), *this; }
        inline poly& resize(int x) { return f.resize(x), *this; }
        inline void clear() { f.resize(1), f[0] = 0; }
        inline void shrink()
        {
            int n = f.size() - 1;
            while (n > 0 && f[n] == 0)
                n--;
            f.resize(n + 1);
        }
        inline void rev() { reverse(f.begin(), f.end()); }
        inline poly split(int n) const
        {
            return n <= 0
                       ? poly(1, 1)
                       : (n < (int)f.size() ? poly(f.begin(), f.begin() + n + 1)
                                            : poly(*this).redegree(n));
        }
        inline int& operator[](const int& x) { return f[x]; }
        inline int operator[](const int& x) const { return f[x]; }
        inline int get(const int& x) { return x < (int)f.size() ? f[x] : 0; }

        inline poly& operator+=(const poly& a)
        {
            if (a.f.size() > f.size()) f.resize(a.size());
            for (int i = a.f.size(); i--;)
                f[i] = (f[i] + a.f[i]) % mod;
            return *this;
        }
        inline poly& operator-=(const poly& a)
        {
            if (a.f.size() > f.size()) f.resize(a.size());
            for (int i = a.f.size(); i--;)
                f[i] = (f[i] + mod - a.f[i]) % mod;
            return *this;
        }
        inline poly operator+(const poly& a) const { return poly(*this) += a; }
        inline poly operator-(const poly& a) const { return poly(*this) -= a; }
        inline poly operator-() const
        {
            poly _f;
            _f.resize(f.size());
            for (int i = f.size(); i--;)
                _f.f[i] = (f[i] ? mod - f[i] : 0);
            return _f;
        }

        inline poly& operator*=(const poly& a)
        {
            if (f.empty() || a.f.empty()) return clear(), *this;
            vec g(a.f);
            const int n = f.size() + g.size() - 1, m = 1 << lg(n);
            f.resize(m), g.resize(m);
            DFT(f), DFT(g);
            for (int i = m; i--;)
                f[i] = (ll)f[i] * g[i] % mod;
            IDFT(f), f.resize(n);
            return *this;
        }
        inline poly operator*(const poly& a) const { return poly(*this) *= a; }

        inline int eval(int x)
        {
            int ret = f[degree()];
            for (int i = degree() - 1; i >= 0; i--)
                ret = ((ll)ret * x + f[i]) % mod;
            return ret;
        }
        inline poly deriv() const
        {
            const int n = degree();
            poly g(n);
            for (int i = 1; i <= n; i++)
                g[i - 1] = (ll)f[i] * i % mod;
            return g;
        }
        inline poly integ(const int& C = 0) const
        {
            const int n = degree();
            poly g(n + 2);
            g[0] = C;
            for (int i = 0; i <= n; i++)
                g[i + 1] = (ll)ginv(i + 1) * f[i] % mod;
            return g;
        }

        inline poly mulT(poly a)
        {
            const int n = a.size();
            reverse(a.f.begin(), a.f.end()), a *= *this;
            return poly(a.f.begin() + n - 1, a.f.end());
        }

        inline poly inv() const;
        inline poly ln() const;
        inline poly exp() const;
        inline poly eval(poly q) const;
    };
    namespace semiconvolution  // f[i] = \sum f[j]g[i-j] (j < i)
    {
        const int mxdep = 30, br = 5;
        vec Tr[mxdep], Ts[mxdep];
        int __SEMI = 0;
        inline void __semi(int m)
        {
            while (__SEMI < m)
                Tr[__SEMI].resize(2 << __SEMI), Ts[__SEMI].resize(2 << __SEMI),
                    __SEMI++;
        }
        //
        inline void src(
            poly& f, const poly& g,
            const function<void(const int&, poly&, const poly&)>& calc)
        {
            const int n = g.size(), m = lg(n - 1);
            f.resize(1 << m), __semi(m);
            for (int i = 0; i < m; i++)
            {
                int len = min(g.size(), (2 << i));
                memcpy(Tr[i].data(), g.f.data(), len << 2);
                DFT(Tr[i]);
            }
            calc(0, f, g);
            for (int i = 1; i < (1 << m); i++)
            {
                const int len = __builtin_ctz(i), nl = i - (1 << len),
                          nr = i + (1 << len);
                if (len < br)
                {
                    for (int j = i; j < nr; j++)
                        for (int k = nl; k < i; k++)
                            f[j] = (f[j] + (ll)f[k] * g[j - k]) % mod;
                    calc(i, f, g);
                    continue;
                }
                memset(Ts[len].data(), 0, (2 << len) << 2);
                memcpy(Ts[len].data(), f.f.data() + nl, (1 << len) << 2);
                DFT(Ts[len]);
                for (int j = 0; j < (2 << len); j++)
                    Ts[len][j] = (ll)Ts[len][j] * Tr[len][j] % mod;
                IDFT(Ts[len]);
                for (int j = i; j < nr; j++)
                    f[j] = (f[j] + Ts[len][j - i + (1 << len)]) % mod;
                calc(i, f, g);
            }
            f.resize(n);
        }
    }  // namespace semiconvolution
    using semiconvolution::src;
    inline poly poly::inv() const
    {
        const int n = size(), m = 1 << lg(n);
        vec _f(f), g({qpow(f[0])});
        _f.resize(m);
        for (int l = 2; l <= m; l <<= 1)
        {
            vec h(_f.begin(), _f.begin() + l);
            g.resize(l << 1), h.resize(l << 1);
            DFT(g), DFT(h);
            for (int i = l << 1; i--;)
                g[i] = (2 - (ll)h[i] * g[i] % mod + mod) * g[i] % mod;
            IDFT(g), g.resize(l);
        }
        g.resize(n);
        return poly(g);
    }
    inline poly poly::ln() const
    {
        const int n = size();
        poly g = deriv(), h = inv();
        g *= h;
        return g.resize(n - 1), g.integ();
    }
    inline poly poly::exp() const
    {
        poly g, h(size());
        for (int i = size(); i--; i)
            h[i] = (ll)f[i] * i % mod;
        src(g, h,
            [&](const int& i, poly& f, const poly& g)
            {
                if (i == 0)
                    f[0] = 1;
                else
                    f[i] = (ll)f[i] * ginv(i) % mod;
            });
        return g;
    }
    namespace multipoint
    {
        vector<poly> Tr;
        poly& __multipoint_build(int p, int l, int r, const poly& q)
        {
            if (l + 1 == r)
                return Tr[p].f = vec{1, (q[l] ? mod - q[l] : 0)}, Tr[p];
            const int mid = l + r >> 1;
            return Tr[p] = __multipoint_build(p << 1, l, mid, q) *
                           __multipoint_build(p << 1 | 1, mid, r, q);
        }
        void __multieval_solve(int p, int l, int r, poly g, poly& f)
        {
            g.resize(r - l);
            if (l + 1 == r) return f[l] = g[0], void();
            const int mid = l + r >> 1;
            __multieval_solve(p << 1, l, mid, g.mulT(Tr[p << 1 | 1]), f);
            __multieval_solve(p << 1 | 1, mid, r, g.mulT(Tr[p << 1]), f);
        }

    }  // namespace multipoint
    inline poly poly::eval(poly q) const
    {
        using namespace multipoint;
        const int m = q.size(), n = max(m, (int)size());
        poly p = *this;
        p.resize(n + 1), q.resize(n), Tr.resize(n << 2);
        __multieval_solve(1, 0, n, p.mulT(__multipoint_build(1, 0, n, q).inv()),
                          q);
        return q.resize(m), q;
    }
}  // namespace Poly

using namespace Poly;
```



### 多项式除法

#### 推导

目前我们已知$F(x)$， $G(x)$，要求$Q(x)$， $R(x)$。 $R(x)$最高次低于$F(x)$
$$
F(x)=Q(x)G(x)+R(x)
$$
不妨设$F(x)$最高次数为$n$，$G(x)$最高次数为$m$。

$n=m$时，$Q(x)$是常数

$n<m$时，$Q(x)$恒为0

$n>m$时，$Q(x)$最高次项为$n-m$， $R(x)$的最高次项系数小于$m$。

不妨将$R(x)$系数用0补全到m-1

考虑移除 $R(x)$的影响，将系数反转得到
$$
x^nF(\frac{1}{x})=x^{n-m}*Q(\frac{1}{x}) *x^{m} *G(\frac{1}{x})+x^{n-m+1}*x^{m-1}*R(\frac{1}{x})
$$
记$F_R(x)$为$F(x)$系数反转后的结果，则有
$$
F_R(x)=Q_R(x)*G_R(x)+x^{n-m+1}*R_R(x)
$$
可以发现此时对$x^{n-m+1}$取模即可消去$R(x)$项同时$Q(x)$最高次项因为不足$x^{n-m+1}$，模意义下求出来的结果就是答案

即对于$Q(x)$，先求出反转后的结果再求出$R(x)$

#### code

```c++
	cin>>n>>m;
    bool ck = 0;
    for(int i=0;i<=n;++i)
    {
    	int x;cin>>x;
    	f.push_back(x);
	}
	for(int i=0;i<=m;++i)
    {
    	int x;cin>>x;
    	g.push_back(x);
	}
	Poly::init(18);
	poly fr(n+1);
	poly gr(m+1);
	
	for(int i=0;i<=n;++i)fr[i]=f[n-i];
	for(int i=0;i<=m;++i)gr[i]=g[m-i];

	fr.resize(n-m+1);gr.resize(n-m+1);
	gr = Poly::poly_inv(gr,n-m+1);
	gr = Poly::poly_mul(gr,fr);
	
	gr.resize(n-m+1);
	reverse(gr.begin(),gr.end());
	
	for(int i=0;i<n-m+1;++i)cout<<gr[i]<<' ';
	cout<<'\n';
	
	gr = Poly::poly_mul(gr,g);
	for(int i=0;i<m;++i)
	{
		int x=(f[i]-gr[i]+mod)%mod;
		cout<<x<<' ';
	}
```



### 多项式优化背包

通常与生成函数联系在一起，用来求方案数等可以求和的东西。

#### 题目

有$n$件商品，每件商品有无数个，求恰好装满$s$容积的背包的方案数

#### 分析

$f = 1 + v ^ 1 + v ^ 2 + \cdots$ 为该背包的背包的一个简单生成，只要$n$个多项式相乘，然后找到幂次为$s$的，对应系数即答案。

一个常见套路是可以取对数来优化。

在3.10.11.7中也许有更详尽的说明

### 拉格朗日插值

#### 公式

已知点对$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$，则有
$$
f(x)=\sum^n_{i=1} y_i \prod_{j \neq i}{\frac{x-x_j}{x_i-x_j} }
$$

#### 任意点对，$O(n^2)$

```c++
//k是最后要求的F(k)
for(int i = 1; i <= n; ++ i) {
    ll s1 = A[i].y % mod;
    ll s2 = 1ll;
    for(int j = 1; j <= n; ++ j) {
        if(i != j) {
            s1 = s1 * (k - A[j].x) % mod;
            s2 = s2 * (A[i].x - A[j].x) % mod;
        }
    }
    ans += s1 * inv(s2) % mod;
}

```

#### 连续点对，$O(n)$

1~n
$$
pre[i]=\prod_{j=0}^{i}(k-j)\\
suf[i]=\prod_{j=i}^{n}(k-j)\\
f(x)=\sum^n_{i=1} y_i \frac{pre[i-1]*suf[i+1]}{fact[i-1]*fact[N-i]}((N-i)\%2 ~? ~ -1:1)
$$

### 斯特林数

#### 第一类斯特林数

##### 记法 

$$
s\left(n,m\right)
$$

或者
$$
\left [ {\begin{matrix}  n \\ m \end{matrix}} \right ]
$$

##### 含义

n个元素构成m个圆排列的方案数

#### 第二类斯特林数

##### 记法 

$$
S\left(n,m\right)
$$

或者
$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \}
$$

##### 含义

将n个不同小球放到m个相同盒子里的方案数。

##### 递推公式

考虑第n个小球，有两种放法，第一种放到前n-1个小球所在的前m个盒子里面，由于这些盒子可以由小球区分开来，因此一共有m种放法，第二种自己放到一个单独的盒子里。
$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} = \left \{ {\begin{matrix}   n-1\\ m-1 \end{matrix}} \right \} + m * \left \{ {\begin{matrix}   n-1\\ m \end{matrix}} \right \}
$$
边界条件
$$
\left \{ {\begin{matrix}   0\\ 0 \end{matrix}} \right \} = 1
$$

$$
\left \{ {\begin{matrix}   n\\ 0 \end{matrix}} \right \} = 0
$$



##### 通项公式

$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} = \cfrac{1}{m!} \sum_{k=0}^m\left(-1\right)^k\binom{m}{k}\left(m-k\right)^n
$$

##### 部分斯特林数

|  n   |                第二类斯特林数                |
| :--: | :------------------------------------------: |
|  0   |                      1                       |
|  1   |                     0 1                      |
|  2   |                    0 1 1                     |
|  3   |                   0 1 3 1                    |
|  4   |                  0 1 7 6 1                   |
|  5   |                0 1 15 25 10 1                |
|  6   |              0 1 31 90 65 15 1               |
|  7   |           0 1 63 301 350 140 21 1            |
|  8   |        0 1 127 966 1701 1050 266 28 1        |
|  9   |     0 1 255 3025 7770 6951 2646 462 36 1     |
|  10  | 0 1 511 9330 34105 42525 22827 5880 750 45 1 |



#### 斯特林数性质

性质1：
$$
m^n = \sum_{i = 0}^{m} \binom{m}{i}\left \{ {\begin{matrix}   n\\ i \end{matrix}} \right \}i!
$$

斯特林数也可以表现为
$$
\sum_{1 \leq x_1<x_2< \cdots <x_n \leq m} \prod_{i=1}^{n} x_i
$$
我们可以这样考虑，现在有$m$个盒子，每个盒子里小球数量表示值为$i$的数有多少个，那么这样对应序列产生的贡献就可以写为$\prod_{i=1}^{m} a_i*i$，现在我们有$n+m$个球（保证序列非空），那么最后一个小球对应的贡献就可以表示为$(\prod_{i=1}^{m-1} a_i*i)*(a_m-1+1)*m$，其中一部分可以理解为$(\prod_{i=1}^{m-1} a_i*i)*m$即$（n+m-1,m)$的情况作为答案在乘以$m$，另一部分即$（n+m-1,m-1)$的情况。

#### 快速求（$O(nlogn)$）

#### 求一行

给定n，求m= 1~$i$的斯特林数

考虑性质1
$$
m^n = \sum_{i = 0}^{m} \binom{m}{i}\left \{ {\begin{matrix}   n\\ i \end{matrix}} \right \}i!
$$
不妨设
$$
f(m) = m^n,g(m) = \left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} m!
$$
于是有
$$
f(m) = \sum_{i=0}^{m}\binom{m}{i}g(i) \\ \iff g(m) = \sum_{i=0}^{m}\binom{m}{i}(-1)^{m-i}f(i) \\ \! ~~~~~~~~~~~~~~~~ =\sum_{i=0}^{m}\binom{m}{i}(-1)^{m-i}i^n
$$
那么我们可以得到
$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} = \sum_{i=0}^{m} \frac {\binom{m}{i}(-1)^{m-i}i^n }{m!}
$$
化简可以得到
$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} = \sum_{i=0}^{m} \frac {(-1)^{m-i}i^n }{i! (m-i)!}
$$
于是我们可以利用NTT求了



```c++
for (int i = 1; i <= n; ++i)
        fact[i] = 1ll * fact[i - 1] * i % mod;
inv[n] = qpow(fact[n] , mod - 2);
for (int i = n - 1; i >= 0; --i)
        inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;
 poly f(n + 1), g(n + 1);
for (int i = 0; i <= n; ++i)
    g[i] = (i & 1 ? mod - 1ll : 1ll) * inv[i] % mod,
           f[i] = 1ll * qpow(i, n) * inv[i] % mod;
Poly::init(21);
f = poly_mul(f, g);
f.resize(n + 1);
```

#### 求一列

考虑递推式
$$
\left \{ {\begin{matrix}   n\\ m \end{matrix}} \right \} = \left \{ {\begin{matrix}   n-1\\ m-1 \end{matrix}} \right \} + m * \left \{ {\begin{matrix}   n-1\\ m \end{matrix}} \right \}
$$

「同一列」的第二类斯特林数指的是，有着不同的 $i$，相同的 $k$的一系列 $\begin{Bmatrix}i\\k\end{Bmatrix}$。求出同一列的所有第二类斯特林数，就是对 $i=0..n$求出了将 $i$ 个不同元素划分为 $k$ 个非空集的方案数。

利用指数型生成函数计算。

一个盒子装 $i$ 个物品且盒子非空的方案数是 $ [i>0] $。我们可以写出它的指数型生成函数为 $F(x)=\sum\limits_{i=1}^{+\infty}\dfrac{x^i}{i!} = \mathrm{e}^x-1$。经过之前的学习，我们明白 $F^k(x)$就是$ i $个有标号物品放到$ k $个有标号盒子里的指数型生成函数，那么除掉 $k!$ 就是 $i$ 个有标号物品放到 $k$个无标号盒子里的指数型生成函数。

$\begin{Bmatrix}i\\k\end{Bmatrix}=\dfrac{\left[\dfrac{x^i}{i!}\right]F^k(x)}{k!}$，$O(n\log n)$ 计算多项式幂即可。

另外，$\exp F(x)=\sum\limits_{i=0}^{+\infty}\dfrac{F^i(x)}{i!}$就是 $i$ 个有标号物品放到任意多个无标号盒子里的指数型生成函数（$EXP$ 通过每项除以一个 $i!$ 去掉了盒子的标号）。这其实就是贝尔数的生成函数。

这里涉及到很多「有标号」「无标号」的内容，注意辨析。

```c++
int main() {
  scanf("%d%d", &n, &k);
  poly f(n + 1);
  fact[0] = 1;
  for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
  for (int i = 1; i <= n; ++i) f[i] = qpow(fact[i], mod - 2);
  f = exp(log(f >> 1) * k) << k, f.resize(n + 1);
  int inv = qpow(fact[k], mod - 2);
  for (int i = 0; i <= n; ++i)
    printf("%lld ", (ll)f[i] * fact[i] % mod * inv % mod);
  return 0;
}
```



### 原根

对于模数$m$

它的原根一定满足$g^{\frac{\varphi(m)}{p} } \neq 1 (\mod m)$

若$g$是一个原根，那么$(k,\varphi(m))=1$，$g^k$也是原根

只有满足$2,4,p^k,2*p^k$，$p$为奇素数，$k$为正整数

设 $m \ge 3, (g,m) = 1 $，则 $g$ 是模 $m$ 的原根的充要条件是，对于 $\varphi(m)$ 的每个素因数 $p$，都有 $g^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod m$.

一个数$m$存在原根，当且仅当$m=2,4,p^{\alpha},2p^{\alpha}$，其中$p$是奇素数。



4179340454199820289的原根是3

998244353 的原根也是3

#### 求原根

```c++
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
using namespace std;
int P;
const int NUM = 32170;
int prime[NUM/4];
bool f[NUM];
int pNum = 0;
void getPrime()//线性筛选素数
{
	for (int i = 2; i < NUM; ++ i)
	{
		if (!f[i])
		{
			f[i] = 1;
			prime[pNum++] = i;
		}
		for (int j = 0; j < pNum && i*prime[j] < NUM; ++ j)
		{
			f[i*prime[j]] = 1;
			if (i%prime[j] == 0)
			{
				break;
			}
		}
	}
}
__int64 getProduct(int a,int b,int P)//快速求次幂mod
{
	__int64 ans = 1;
	__int64 tmp = a;
	while (b)
	{
		if (b&1)
		{
			ans = ans*tmp%P;
		}
		tmp = tmp*tmp%P;
		b>>=1;
	}
	return ans;
}
 
bool judge(int num)//求num的所有的质因子
{
	int elem[1000];
	int elemNum = 0;
	int k = P - 1;
	for (int i = 0; i < pNum; ++ i)
	{
		bool flag = false;
		while (!(k%prime[i]))
		{
			flag = true;
			k /= prime[i];
		}
		if (flag)
		{
			elem[elemNum ++] = prime[i];
		}
		if (k==1)
		{
			break;
		}
		if (k/prime[i]<prime[i])
		{
			elem[elemNum ++] = prime[i];
			break;
		}
	}
	bool flag = true;
	for (int i = 0; i < elemNum; ++ i)
	{
		if (getProduct(num,(P-1)/elem[i],P) == 1)
		{
			flag = false;
			break;
		}
	}
	return flag;
}
int main()
{
	
	getPrime();
	while (cin >> P)
	{
		for (int i = 2;;++i)
		{
			if (judge(i))
			{
				cout << i<< endl;
				break;
			}
		}
	}
	return 0;
}
```

#### 判断原根

对于素数，合数需要将$p-1$换成$\phi(p)$

```c++
ll modPow(ll a, int n, int p)
{
    ll res = 1;
    while (n)
    {
        if (n & 1)
            res = res * a % p;
        n >>= 1;
        a = a * a % p;
    }
    return res;
}
void init(int P)
{
    int lim = sqrt(P);
    for (int i = 2; i <= lim; ++i)
        if ((P - 1) % i == 0)
            fac[cnt++] = i, fac[cnt++] = (P - 1) / i;
}
bool check(int x, int P)
{
    for (int i = 0; i < cnt; ++i)
        if (modpow(x, fac[i], P) == 1)
            return false;
    return true;
}
```



### cdq分治

#### 优化决策单调性

在仅知道决策单调性，没有其他性质的情况下，我们可以使用cdq分治来维护

```c++
ll f(int L, int R)
{
	static ll l = 1, r = 0, ans = 0;
    //类似莫队去维护
	auto del = [&](int i)	
	{
		cnt[pre[i]]--;
		ans -= cnt[pre[i] ^ d];
	};
	auto add = [&](int i)	
	{
		ans += cnt[pre[i] ^ d];
		cnt[pre[i]]++;
	};
	while(l > L) add(--l);
	while(l < L) del(l++);
	while(r > R) del(r--);
	while(r < R) add(++r);
	return ans; 
} 
```

cdq的主函数

```c++
void dfs(int l, int r, int pl, int pr)
{
    if(l > r || pl > pr) return ;
    int mid = (l + r) >> 1;
 
    int mxp = -1;
    for(int i = pl; i <= min(mid, pr); ++i)
    {
    	ll val = g[i] + f(i, mid);
    	if(val < dp[mid])
    	{
    		dp[mid] = val;
    		mxp = i;
		}
	}
    dfs(l, mid - 1, pl, mxp);
    dfs(mid + 1, r, mxp, pr);

}
```

#### 解决和点对有关的问题

这类问题多数类似于「给定一个长度为 n 的序列，统计有一些特性的点对 $(i,j)$的数量/找到一对点$ (i,j) $使得一些函数的值最大」。

CDQ 分治解决这类问题的算法流程如下：

1. 找到这个序列的中点 $mid$；
2. 将所有点对$(i,j)$划分为 3 类：
   1. $1\le i,j\le mid$
   2. $mid+1\le i,j\le r$
   3. $1\le i\le mid, mid+1 \le j \le r$
3. 将 $(1,n)$这个序列拆成两个序列 $(1,mid)$和 $(mid+1,n)$。此时第一类点对和第三类点对都在这两个序列之中；
4. 递归地处理这两类点对；
5. 设法处理第二类点对。

#### 题目 cdq优化卷积

$$
f_0=1\\
f_i=\sum_{j=1}^{i}f_{i-j}g_j
$$

考虑如何计算左区间对右区间的贡献即可。

```c++
void work(poly &g, int l, int r, int n) 
{
	if(l == r)
	{
		return ;
	}
	int mid = (l + r) >> 1;
	
	work(g, l, mid, n);
	
	poly r1(mid - l + 1, 0), r2(r - l + 1, 0);
	for(int i = l; i <= mid; ++i)
	{
		r1[i - l] = f[i];
	}
	for(int i = 0; i < r - l + 1; ++i)
	{
		r2[i] = g[i];
	}
	poly res = poly_mul(r1, r2);
	for(int i = mid - l + 1; i < min((int)res.size(), r - l + 1); ++i)
	{
		
		f[i + l] += res[i];
		if(f[i + l] > mod) f[i + l] -= mod;
		
	}
	work(g, mid + 1, r, n); 
}
```

传参数的时候注意$g$传引用值，不然会惨遭$TLE$​

#### cdq 优化多个多项式相乘

注意，必须是多个一次项相乘，如果不是，则参考多项式优化背包部分。

```c++
auto cdq1 = [&](auto  self, int l, int r) -> poly
{
    if(l == r)
    {
        poly f(2, 0);
        //这里计算f函数
        return f;
    }
    int mid = (l + r) >> 1;
    poly f1 = self(self, l, mid);
    poly f2 = self(self, mid + 1, r);
    poly f = poly_mul(f1, f2);
    return f;
};
```



### FFT



#### 前置知识

##### 复数

##### 性质

$$
性质一· ~~~\omega^{2k}_{2n} = \omega^{k}_{n}\\
性质二· ~~~\omega^{k+\frac{n}{2}}_{2n} = - \omega^{k}_{n}
$$



#### 用法

多项式乘法，卷积

#### 原理

一个n次多项式可以有两种表示方法，点值表示法和系数表示法

在用系数表示法的前提下，即朴素写法，我们需要$\Theta(n^2)$的时间来完成

在点值表示下，可以仅$\Theta(n)$的时间完成

因此我们考虑如何将点值表示与系数表示进行快速转换

不妨记
$$
A(x) = \sum_{i=0}^{n-1}a_ix^i
$$


在这里，我们可以令高次项$a_i=0$从而使n变大

考虑
$$
A(x) = (a_0+a_2 x^2 + \cdots  + a_{n-2}x^{n-2} ) + x(a_1 +a_3 x^2 + \cdots +  a_{n-1}x^{n-1})
$$
令
$$
A1(x) =(a_0+a_2 x + ……  a_{n-2}x^{ \frac{n-2}{2} } )\\
A2(x) = (a_1+a_3 x + ……   a_{n-1}x^{ \frac{n-2}{2}})
$$
于是有
$$
A(X) = A1(x^2) + A2(x^2)
$$
带入单位根$(0\leq k \leq \frac{n}{2} -1 )$得

左半部分
$$
A(\omega^k_n) = A1(\omega^{2k}_n)+\omega^{k}_n*A2(\omega^{k}_\frac{n}{2})\\
=A1(\omega^{k}_\frac{n}{2}) + \omega^{k}_n*A2(\omega^{2k}_n)(折半引理，性质1)\\
$$
右半部分
$$
A(\omega^{k+\frac{n}{2}}_n) = A1(\omega^{2k+n}_n)+\omega^{k+\frac{n}{2}}_n * A2(\omega^{2k+n}_n)
$$
运算得
$$
A(\omega^{k+\frac{n}{2}}_n) = A1(\omega^{k}_{\frac{n}{2}}) - \omega^{k}_n * A2(\omega^{k}_{\frac{n}{2}})
$$
则问题为求$A1(x)与A2(x)$，总体时间复杂度为$T(n) = 2T(\frac{n}{2})+O(n) = O(nlogn)$,即实现了FFT转换

#### 代码

```c++
N 应该5倍大小
const db PI=acos(-1);
n = A的最高次数
m = B的最高次数    
Lim = 1， L = 0; 

int R[N];
struct Complex
{
    double x, y;
    Complex (double x = 0, double y = 0) : x(x), y(y) { }
}a[N], b[N];
Complex operator * (Complex J, Complex Q) {
    //模长相乘，幅度相加
    return Complex(J.x * Q.x - J.y * Q.y, J.x * Q.y + 			J.y * Q.x);
}
Complex operator - (Complex J, Complex Q) {
    return Complex(J.x - Q.x, J.y - Q.y);
}
Complex operator + (Complex J, Complex Q) {
    return Complex(J.x + Q.x, J.y + Q.y);
}
//for (int i = 0; i <= Lim; ++ i) {
    //换成二进制序列
    //R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
    // 在原序列中 i 与 i/2 的关系是 ： i可以看做是i/2的二进制上的每一位左移一位得来
    // 那么在反转后的数组中就需要右移一位，同时特殊处理一下奇数
//}

inline void FFT(Complex *J, double type)//1 转点值，-1 转系数
{
    for(int i = 0; i < Lim; ++ i) {
        if(i < R[i]) swap(J[i], J[R[i]]);
        //i小于R[i]时才交换，防止同一个元素交换两次，回到它原来的位置。
    }
    //从底层往上合并
    for(int mid = 1; mid < Lim; mid <<= 1) {//待合并区间长度的一半，最开始是两个长度为1的序列合并,mid = 1;
        Complex wn(cos(PI / mid), type * sin(PI / mid));//单位根w_n^i;
        for(int len = mid << 1, pos = 0; pos < Lim; pos += len) {
        //for(int pos = 0; pos < Lim; pos += (mid << 1)) {
            //len是区间的长度，pos是当前的位置,也就是合并到了哪一位
            Complex w(1, 0);//幂,一直乘，得到平方，三次方...
            for(int k = 0; k < mid; ++ k, w = w * wn) {
                //只扫左半部分，得到右半部分的答案,w 为 w_n^k
                Complex x = J[pos + k];//左半部分
                Complex y = w * J[pos + mid + k];//右半部分
                J[pos + k] = x + y;//蝴蝶变换
                J[pos + mid + k] = x - y;
            }
        }
    }
    if(type == 1) return ;
    for(int i = 0; i <= Lim; ++ i)
        a[i].x /= Lim, a[i].y /= Lim;
}
cin>>n>>m;
for(int i=0;i<=n;++i)cin>>a[i].x;
for(int j=0;j<=m;++j)cin>>a[j].y;
while(Lim < n + m) Lim <<= 1, L ++ ;
for (int i = 0; i < Lim; ++ i) {
    //换成二进制序列
    R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
}
FFT(a, 1);
for (int i = 0; i <= Lim; ++ i) 
    //对应项相乘，O(n)得到点值表示的多项式的解C，利用逆变换完成插值得到答案C的点值表示
    	a[i] = a[i] * a[i];
FFT(a, -1);
```



### FWT

#### 前置

我们定义 $\times$ 是多项式对应系数相乘，* 作为多项式卷积

 其中 $\bigoplus$是二元位运算符，即 与$(\&)$，或$(|)$，异或$(\wedge)$

我们记对数组 $A$ 进行快速沃尔什变换后得到的结果为$FWT[A]$ 。

那么 FWT 核心思想就是：

我们需要一个新序列$C$，由序列$A$ 和序列$B$经过某运算规则得到，即 $C = A \cdot B$；

我们先正向得到 $FWT[A], FWT[B]]$，再根据 $FWT[C]=FWT[A]  \times FWT[B]$在 $O(n)$ 的时间复杂度内求出 $FWT[C]$；

然后逆向运算得到原序列 $C$。时间复杂度为 $O(n \log n)$

#### 用途

用于下标位运算卷积问题

#### 或运算

注意到，
$$
i|k=k,j|k=k \Rightarrow (i|j)|k = k
$$
于是构造如下式子
$$
FWT[A](i) = A' = \sum_{i=i|j}A_{j}
$$

##### 性质

$$
1. ~~FWT[A+B] = FWT[A] + FWT[B]
$$

$FWT$是$A$序列的一个线性组合
$$
2. ~~ FWT[A] =  \begin{cases}
merge(FWT[A_0] ,FWT[A_0] +FWT[A_1] )~~,~~ n>1 \\
A ~~,~~n =0
\end{cases}
$$
$A_0$是$A$的左半部分，$A_1$是$A$的右半部分。对于$A_0$中的任意下标$i$，都可以在$A_1$中找到在二进制下除最高位以外都相同的下标$j$。

由于最高位不同，右半部分不会对最半部分产生贡献，$FWT[A]_0=FWT[A_0]$

同理可得，$FWT[A]_1=FWT[A_0]+FWT[A_1]$
$$
3. ~~ FWT[A|B] = FWT[A] \times FWT[B]
$$
展开即可证明

##### 逆运算

$$
IFWT[A] =  \begin{cases}
merge(IFWT[A_0] ,IFWT[A_1] -IFWT[A_0] )~~,~~ n>1 \\
A ~~,~~n =0
\end{cases}
$$

#### 与运算

同或运算

#### 异或运算

fwt式子略有不同
$$
FWT[A](i)=\sum_{d(i \& j) ~~mod 2 ~~ \equiv ~~0}A_j-\sum_{d(i \& j) ~~mod 2 ~~ \equiv ~~1}A_j
$$
其中$d(x)$表示$x$在二进制下的1的个数

性质与或运算相同

#### Code

##### 数组版本

```c++
inline void in() //防止污染原数组
{
    for(int i = 0; i < n; ++ i)
        a[i] = A[i], b[i] = B[i];
}

inline void get()
{
    for(int i = 0; i < n; ++ i)
        a[i] = a[i] * b[i] % mod;
}

inline void out()
{
    for(int i = 0; i < n; ++ i)
        printf("%lld%s", (a[i] % mod + mod) % mod, i == (n - 1) ? "\n" : " ");
}


inline void OR(ll *f, int x = 1)//前半部分 f[i + j], 后半部分 f[i + j + k]
{
    for(int o = 2; o <= n; o <<= 1)
        for(int i = 0, k = o >> 1; i < n; i += o)
            for(int j = 0; j < k; ++ j)
                f[i + j + k] = (f[i + j] * x + f[i + j + k] + (x == 1 ? 0 : mod)) % mod;

}

inline void AND(ll *f, int x = 1)//前半部分 f[i + j],后半部分 f[i + j + k]
{
    for(int o = 2; o <= n; o <<= 1)
        for(int i = 0, k = o >> 1; i < n; i += o)
            for(int j = 0; j < k; ++ j)
                f[i + j] = (f[i + j] + f[i + j + k] * x + (x == 1 ? 0 : mod)) % mod;

}

inline void XOR(ll *f, int x = 1)//前半部分 f[i + j],后半部分 f[i + j + k]
{
    for(int o = 2; o <= n; o <<= 1)
        for(int i = 0, k = o >> 1; i < n; i += o)
            for(int j = 0; j < k; ++ j) {
                int X = f[i + j], Y = f[i + j + k];
                f[i + j] = (X + Y) % mod;
                f[i + j + k] = (X - Y % mod + mod) % mod;
                if(x != 1) {
                    f[i + j] = f[i + j] * inv2 % mod;
                    f[i + j + k] = f[i + j + k] * inv2 % mod;
                }
            }
}

int main()
{
    scanf("%d", &m);
    n = 1 << m;
    for(int i = 0; i < n; ++ i)
        scanf("%lld", &A[i]);
    for(int i = 0; i < n; ++ i)
        scanf("%lld", &B[i]);
    in(), OR(a), OR(b), get(), OR(a, -1), out();
    in(), AND(a), AND(b), get(), AND(a, -1), out();
    in(), XOR(a), XOR(b), get(), XOR(a, -1), out();
    return 0;
}
```



##### Vector版本

```c++
struct FWT {
    void add(int &x, int y) {
        (x += y) >= P && (x -= P);
    }
    void sub(int &x, int y) {
        (x -= y) < 0 && (x += P);
    }
    
    int extend(int n) {
        int N = 1;
        for (; N < n; N <<= 1);
        return N;
    }
    void FWTor( vector<int> &a, bool rev) {
        int n = a.size();
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                if (!rev) add(a[i + j + m], a[i + j]);
                else sub(a[i + j + m], a[i + j]);
            }
        }
    }
    void FWTand( vector<int> &a, bool rev) {
        int n = a.size();
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                if (!rev) add(a[i + j], a[i + j + m]);
                else sub(a[i + j], a[i + j + m]);
            }
        }
    }
    void FWTxor( vector<int> &a, bool rev) {
        int n = a.size(), inv2 = (P + 1) >> 1;
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                int x = a[i + j], y = a[i + j + m];
                if (!rev) {
                    a[i + j] = (x + y) % P;
                    a[i + j + m] = (x - y + P) % P;
                } else {
                    a[i + j] = 1LL * (x + y) * inv2 % P;
                    a[i + j + m] = 1LL * (x - y + P) * inv2 % P;
                }
            }
        }
    }
    vector<int> Or(vector<int> a1, vector<int> a2) {
        int n = max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTor(a1, false);
        a2.resize(N), FWTor(a2, false);
        vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTor(A, true);
        return A;
    }
    vector<int> And(vector<int> a1, vector<int> a2) {
        int n =  max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTand(a1, false);
        a2.resize(N), FWTand(a2, false);
        vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTand(A, true);
        return A;
    }
     vector<int> Xor(vector<int> a1, vector<int> a2) {
        int n = max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTxor(a1, false);
        a2.resize(N), FWTxor(a2, false);
        vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTxor(A, true);
        return A;
    }
} fwt;

//main部分
    scanf("%d", &m);
    n = 1 << m;
    vector<int> a1(n), a2(n);
    for (int i = 0; i < n; i++) scanf("%d", &a1[i]);
    for (int i = 0; i < n; i++) scanf("%d", &a2[i]);
    vector<int> A;
    A = fwt.Or(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
    A = fwt.And(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
    A = fwt.Xor(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
```



### MTT（任意模数）

#### FFT

```c++
//luoguP4245 【模板】MTT 
#include<cstdio>
#include<cmath>
#include<algorithm>
const int N = 4e5 + 10, M = 32767;
const double pi = acos(-1.0);
typedef long long LL;

int read() {
    char ch = getchar(); int f = 1, x = 0;
    for(;ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
    for(;ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) - '0' + ch;
    return x * f;
}
struct cp {
    double r, i;
    cp(double _r = 0, double _i = 0) : r(_r), i(_i) {}
    cp operator * (const cp &a) {return cp(r * a.r - i * a.i, r * a.i + i * a.r);}
    cp operator + (const cp &a) {return cp(r + a.r, i + a.i);}
    cp operator - (const cp &a) {return cp(r - a.r, i - a.i);}
}w[N], nw[N], da[N], db[N];

cp conj(cp a) {return cp(a.r, -a.i);}

int L , R[N], P=1e9+7;

void Pre(int n, int m) {
    int x = 0; for(L = 1; (L <<= 1) <= n + m; ++x) ;
    for(int i = 1;i < L; ++i) R[i] = (R[i >> 1] >> 1) | (i & 1) << x;
    for(int i = 0;i < L; ++i) w[i] = cp(cos(2 * pi * i / L), sin(2 * pi * i / L));
}

void FFT(cp *F) {
    for(int i = 0;i < L; ++i) if(i < R[i]) std::swap(F[i], F[R[i]]);
    for(int i = 2, d = L >> 1;i <= L; i <<= 1, d >>= 1) 
        for(int j = 0;j < L; j += i) {
            cp *l = F + j, *r = F + j + (i >> 1), *p = w, tp;
            for(int k = 0;k < (i >> 1); ++k, ++l, ++r, p += d) 
                tp = *r * *p, *r = *l - tp, *l = *l + tp;
        }
}
//值域可达1e18
void Mul(int *A, int *B, int *C) {
    for(int i = 0;i < L; ++i) (A[i] += P) %= P, (B[i] += P) %= P;
    static cp a[N], b[N], Da[N], Db[N], Dc[N], Dd[N];
    for(int i = 0;i < L; ++i) a[i] = cp(A[i] & M, A[i] >> 15);
    for(int i = 0;i < L; ++i) b[i] = cp(B[i] & M, B[i] >> 15);
    FFT(a); FFT(b);
    for(int i = 0;i < L; ++i) {
        int j = (L - i) & (L - 1); static cp da, db, dc, dd;
        da = (a[i] + conj(a[j])) * cp(0.5, 0);
        db = (a[i] - conj(a[j])) * cp(0, -0.5);
        dc = (b[i] + conj(b[j])) * cp(0.5, 0);
        dd = (b[i] - conj(b[j])) * cp(0, -0.5);
        Da[j] = da * dc; Db[j] = da * dd; Dc[j] = db * dc; Dd[j] = db * dd; //顺便区间反转，方便等会直接用DFT代替IDFT 
    }
    for(int i = 0;i < L; ++i) a[i] = Da[i] + Db[i] * cp(0, 1);
    for(int i = 0;i < L; ++i) b[i] = Dc[i] + Dd[i] * cp(0, 1);
    FFT(a); FFT(b);
    for(int i = 0;i < L; ++i) {
        int da = (LL) (a[i].r / L + 0.5) % P; //直接取实部和虚部 
        int db = (LL) (a[i].i / L + 0.5) % P;
        int dc = (LL) (b[i].r / L + 0.5) % P;
        int dd = (LL) (b[i].i / L + 0.5) % P;
        C[i] = (da + ((LL)(db + dc) << 15) + ((LL)dd << 30)) % P; 
    }
}
int a[N], b[N], c[N];
int main() {
    n = read(); m = read(); 
	P = read();
    for(int i = 0;i <= n; ++i) a[i] = read();
    for(int j = 0;j <= m; ++j) b[j] = read();
    Pre(); Mul(a, b, c); 
    for(int i = 0;i <= n + m; ++i) printf("%d ", (c[i] + P) % P); puts("");
    return 0;
}
```

#### 三模数

```c++
#include<bits/stdc++.h>
#define rep(i,a,b) for(auto i=(a);i<=(b);++i)
#define per(a,b) for(auto i=(a);i>=(b);--i)
#define pb push_back
#define pii pair<int,int>
#define pll pair<long long,long long>
#define db double
#define IL inline
#define fir first
#define sec second
#define eps (1e-10)
#define mkp make_pair
//#define rep((a),(b)) for(int i=(a);i<=(b);++i)
#define lowbit(x) (x&(-x))
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
typedef  unsigned long long ull;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int dx[8] = {0,1,0,-1,1,1,-1,-1}, dy[8] = {1,0,-1,0,1,-1,1,-1};
// const ll mod = 998244353;//1e9+7;
const int N = 2e6 + 10,M = 4e4 + 10;

ll qpow(ll a, ll b, ll mod)
{
	ll res = 1;
	while(b)
	{
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
template <int mod = 998244353, int G = 3, int tt = 22>
struct Poly
{
    #define mul(x, y) (1ll * x * y >= mod ? 1ll * x * y % mod : 1ll * x * y)
    #define minus(x, y) (1ll * x - y < 0 ? 1ll * x - y + mod : 1ll * x - y)
    #define plus(x, y) (1ll * x + y >= mod ? 1ll * x + y - mod : 1ll * x + y)//上面其实没用到
    #define ck(x) (x >= mod ? x - mod : x)//取模运算太慢了
    typedef vector<int> poly;


    const int inv_G = qpow(G, mod - 2, mod);
    int deer[2][tt][(1 << tt)];
    int RR[(1 << (tt + 1))], inv[(1 << tt)];
    // vector<int> RR((1 << (tt + 1)), 0), inv((1 << tt), 0);
    poly A, B;

    void init(const int t) {//预处理出来NTT里需要的w和wn，砍掉了一个log的时间
    	assert(t < tt);//一定要注意！！ 
        for(int p = 1; p <= t; ++ p) {
            int buf1 = qpow(G, (mod - 1) / (1 << p), mod);
            int buf0 = qpow(inv_G, (mod - 1) / (1 << p), mod);
            deer[0][p][0] = deer[1][p][0] = 1;
            for(int i = 1; i < (1 << p); ++ i) {
                deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆
                deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod;
            }
        }
        inv[1] = 1;
        for(int i = 2; i <= (1 << t); ++ i)
            inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod;
    }

    int NTT_init(int n) {//快速数论变换预处理
        int limit = 1, L = 0;
        while(limit <= n) limit <<= 1, L ++ ;
        assert(L < tt);
        assert(limit < 1 << (tt + 1));
        for(int i = 0; i < limit; ++ i)
            RR[i] = (RR[i >> 1] >> 1) | ((i & 1) << (L - 1));
        return limit;
    }

    void NTT(poly &A, bool type, int limit) {//快速数论变换
        A.resize(limit);
        for(int i = 0; i < limit; ++ i)
            if(i < RR[i])
                swap(A[i], A[RR[i]]);
        for(int mid = 2, j = 1; mid <= limit; mid <<= 1, ++ j) {
            int len = mid >> 1;
            for(int pos = 0; pos < limit; pos += mid) {
//                auto wn = deer[type][j].begin();
                for(int i = pos, p = 0; i < pos + len; ++ i, ++ p) {
                    int tmp = 1ll * deer[type][j][p] * A[i + len] % mod;
                    A[i + len] = ck(A[i] - tmp + mod);
                    A[i] = ck(A[i] + tmp);
                }
            }
        }
        if(type == 0) {
            for(int i = 0; i < limit; ++ i)
                A[i] = 1ll * A[i] * inv[limit] % mod;
        }
    }

    void poly_mul() {//多项式乘法
        int deg = A.size() + B.size() - 1;
        int limit = NTT_init(deg);
        // poly C(limit);
        NTT(A, 1, limit);
        NTT(B, 1, limit);
        for(int i = 0; i < limit; ++ i)
            A[i] = 1ll * A[i] * B[i] % mod;
        NTT(A, 0, limit);
        A.resize(deg);
        // return C;
    }
    
};


const int mod1 = 998244353, mod2 = 1004535809, mod3 =  469762049;
int n, m, x, k, type;
Poly<mod1, 3, 19> f1;
Poly<mod2, 3, 19> f2;
Poly<mod3, 3, 19> f3;
vector<ll> g;
const ll mod12 = 1ll * mod1 * mod2, imod1 = qpow(mod1 % mod2, mod2 - 2, mod2);
const ll imod12 = qpow(mod12 % mod3, mod3 - 2, mod3);

void Poly_mul(ll P)
{
	f1.init(18);
	f2.init(18);
	f3.init(18);
	f1.poly_mul();
	f2.poly_mul();
	f3.poly_mul();
	int n = f1.A.size();
	g.resize(n);
	for(int i = 0; i < n; ++i)
	{
		ll x = f1.A[i], y = f2.A[i], z = f3.A[i];
		// ans = km + a1 -> k = (ans - a1) * m ^ (-1) 
		x = (((__int128)y - x % mod2 + mod2) % mod2 * imod1 % mod2 * mod1 + x) % mod12;
		g[i] = ((((__int128)z - x) % mod3 + mod3) % mod3 * imod12 % mod3 * (mod12 % P) % P + x % P) % P;
	}
}


void solve(int cas)
{
	int n, m; ll P;
	cin >> n >> m >> P;
	for(int i = 0; i <= n; ++i)
	{
		int x; cin >> x;
		f1.A.pb(x);
	}
	f2.A = f1.A;
	f3.A = f1.A;
	for(int i = 0; i <= m; ++i)
	{
		int x; cin >> x;
		f1.B.pb(x);
	}
	f2.B = f1.B;
	f3.B = f1.B;
	Poly_mul(P);
	for(auto x : g)
		cout << x << ' ';
} 

```



```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
int mod;
int qpow(int base, int p, const int mod)
{
	int res;
	for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
	return res;
}
int inv(int x, const int mod) { return qpow(x, mod - 2, mod); }


const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, G = 3;

const long long mod_1_2 = 1ll * mod1 * mod2;

const int inv_1 = inv(mod1, mod2), inv_2 = inv(mod_1_2 % mod3, mod3);

struct Int {
	int A, B, C;
	Int() { }
	Int(int __num) : A(__num), B(__num), C(__num) { }
	Int(int __A, int __B, int __C) : A(__A), B(__B), C(__C) { }
	
	static inline Int reduce(const Int &x) {
		return Int(x.A + (x.A >> 31 & mod1), x.B + (x.B >> 31 & mod2), x.C + (x.C >> 31 & mod3));
	}
	inline friend Int operator + (const Int &lhs, const Int &rhs) {
		return reduce(Int(lhs.A + rhs.A - mod1, lhs.B + rhs.B - mod2, lhs.C + rhs.C - mod3));
	}
	inline friend Int operator - (const Int &lhs, const Int &rhs) {
		return reduce(Int(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C));
	}
	inline friend Int operator * (const Int &lhs, const Int &rhs) {
		return Int(static_cast<long long> (lhs.A) * rhs.A % mod1, static_cast<long long> (lhs.B) * rhs.B % mod2, static_cast<long long> (lhs.C) * rhs.C % mod3);
	}
	
	inline int get() {
		long long x = 1ll * (B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A;
		return (1ll * (C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;
	}
} ;

#define maxn 131072

namespace Poly {
#define N (maxn << 1)
	int lim, s, rev[N];
	Int Wn[N | 1];
	inline void init(int n) {
		s = -1, lim = 1; while (lim < n) lim <<= 1, ++s;
		for (register int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const Int t(qpow(G, (mod1 - 1) / lim, mod1), qpow(G, (mod2 - 1) / lim, mod2), qpow(G, (mod3 - 1) / lim, mod3));
		*Wn = Int(1); for (register Int *i = Wn; i != Wn + lim; ++i) *(i + 1) = *i * t;
	}
	inline void NTT(Int *A, const int op = 1) {
		for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1) {
				for (register int j = 0; j < mid; ++j) {
					const Int W = op ? Wn[t * j] : Wn[lim - t * j];
					const Int X = A[i + j], Y = A[i + j + mid] * W;
					A[i + j] = X + Y, A[i + j + mid] = X - Y;
				}
			}
		}
		if (!op) {
			const Int ilim(inv(lim, mod1), inv(lim, mod2), inv(lim, mod3));
			for (register Int *i = A; i != A + lim; ++i) *i = (*i) * ilim;
		}
	}
#undef N
}

int n, m;
Int A[maxn << 1], B[maxn << 1];
int main() {
	scanf("%d%d%d", &n, &m, &mod); ++n, ++m;
	for (int i = 0, x; i < n; ++i) scanf("%d", &x), A[i] = Int(x % mod);
	for (int i = 0, x; i < m; ++i) scanf("%d", &x), B[i] = Int(x % mod);
	
	Poly::init(n + m);
	Poly::NTT(A), Poly::NTT(B);
	
	for (int i = 0; i < Poly::lim; ++i) A[i] = A[i] * B[i];
	
	Poly::NTT(A, 0);
	
	for (int i = 0; i < n + m - 1; ++i) {
		printf("%d", A[i].get());
		putchar(i == n + m - 2 ? '\n' : ' ');
	}
	return 0;
}
```

