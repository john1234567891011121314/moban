## 组合数学
### 一些常识

#### 错排

$$
D(n) = (n - 1) * (D(n - 1) + D(n - 2))
$$

$$
D(n) = n! * \sum_{k = 2}^{n} \frac{(-1)^k}{k!}
$$

从中有，当排列够长时，都不在原位的概率为$\frac{1}{e}$，期望在原位的个数是$1$

### 线性求逆元

```c++
void pre_inv(int n)
{
    inv[1] = 1;
    for(int i = 2; i <= n; ++i)
    {
        inv[i] = (1ll * inv[mod % i] * (-mod / i) % mod + mod) % mod;
    }
}
```



### 母函数

#### 母函数重要思想

**将组合问题的加法与幂级数的乘幂对应起来**

#### hint

通常而言，我们将普通母函数处理组合问题，指数母函数处理排列问题

$$
1 + x + x ^ 2 + \cdots = \frac{1}{1 - x} \\
(1 + x) ^ {- m} = \sum_{i = 0} \tbinom{m + i - 1}{i} * x ^ i = \sum_{i = 0} C_{m + i - 1}^{i} * (-1) ^ {i} * x ^ i \\

(1 + x) ^ {m} = \sum_{i = 0} \tbinom{m}{i} * x ^ i
$$


### 整数划分

将$n$划分为若干个不超过$m$的数的方案数 

```c++
for(int i = 1; i <= n; ++i)
{
    for(int j = 1; j <= m; ++j)
    {
        if(i == 1 || j == 1) dp[i][j] = 1;
        else if(i < j) dp[i][j] = dp[i][i]; 
        else if(n == m) dp[i][j] = 1;
        else dp[i][j] = dp[i][j - 1] +  dp[i - j][j]; 
    }
}
```



### 组合数

```c++
void init(int n)
{
    fac[0] = 1;
    for(int i = 1; i <= n; ++i) fac[i] = 1ll * i * fac[i - 1] % mod;
    ifac[n] = qpow(fac[n], mod - 2);
    for(int i = n; i; --i) ifac[i - 1] = 1ll * ifac[i] % mod; 
}
ll C(int n, int m)
{
    if(m < 0 || m > n || n < 0) return 0;
    return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}
```

#### 错排

完全错排公式为
$$
D(n) = (n - 1) (D(n - 1) + D(n  - 2))
$$
假设将第一个元素放到第k位，那么对于第k位的元素，有两种情况 

1.k放在第1位，此时相当于对处第1位与第k位的n-2个元素错排，方案数D（n-2） 

2.k不放在第1位，此时可以看做将第k位与第1位交换，对除第k位以外的元素进行错排，方案数D（n-1）

 考虑k有n-1种选择，于是就有上式

有m个物品位置不变，则方案数为$C^m_n*D(n - m)$

#### 二项式定理

$$
(a+b)^n = a^n +C_n^1a^{n-1}b+\cdots +C_n^{n-1} ab^{n-1}  = \sum_{i=0}^nC_n^ia^ib^{n-i}\\
(a+b)^\alpha  = \sum_{i=0}^{\infty} \tbinom{\alpha}{i} a^ib^{n-i},\tbinom{\alpha}{i} = \frac {\alpha * (\alpha - 1) * \cdots *(\alpha - i + 1)}{i !} \\
(a+b)^{-\alpha}  = \sum_{i=0}^{\infty} \tbinom{-\alpha}{i}
a^ib^{n-i},\tbinom{\alpha}{i} = (-1)^i * (\tbinom{\alpha +i - 1}{i})\\
\sum_{i=0}^{k} \tbinom{n}{i} \tbinom{m}{k-i}=\tbinom{n+m}{k}
$$

#### 常用公式

$$
C_n^k=C_{n-1}^{k-1}+C_{n-1}^{k}\\
C_{n}^{k}=C_{n}^{n-k}\\
C_{n}^{k}=\frac{n-k+1}{k}C_{n}^{k-1}\\
\sum_{i=0}^{n}C_{n}^{i}=2^n\\
\sum_{i=0}^{n} i* C_{n}^{i}=n * 2^{n-1}\\
\sum_{i=1,3,5,7,\cdots}^{n}C_{n}^{i}=\sum_{i=0,2,4,6,\cdots}^{n}C_{n}^{i}=2^{n-1}\\
\sum_{i=0}^{S}C_{n}^{i}C_{m}^{S-i}=C_{n+m}^{s}
$$

#### $lucas$定理

若$p$为素数，则有
$$
C_{n}^{m} = \prod_{i=0}^{k} C_{n_i}^{m_i}(\mod p)\\
n=\sum_{i=0}^{k}n_i*p^i \\
m=\sum_{i=0}^{k}m_i*p^i \\
C_{n}^{m} = C_{n \% p }^{m \% p} *C_{n \backslash p }^{m \backslash p}
$$

```c++
ll lucas(ll n, ll m)
{
    if(n < m) return 0;
    if(!m || n == m) return 1;
    return C(n % P, m % P) * lucas(n / P, m / P) % P;
}
```

#### 扩展卢卡斯定理

```c++
void exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b) 
	{
		x = 1, y = 0;
		return ;
	}
	exgcd(b, a % b, x, y);
	ll tmp = x; x = y; y = tmp - a / b * y;
}
ll INV(ll a, ll p)
{
	ll x, y;
	exgcd(a, p, x, y);
	return (x + p) % p;
}
ll qpow(ll a, ll b, ll p)
{
	ll res = 1;
	a %= p;
	while(b)
	{
		if(b & 1) res = res * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return res;
}
struct EXLucas {
	ll F(ll n, ll P, ll PK)
	{
		if(n == 0) return 1;
		ll rou = 1, rem = 1;
		for(int i = 1; i <= PK; ++i)
		{
			if(i % P) rou = rou * i % PK;
		}
		rou = qpow(rou, n / PK, PK);
		for(ll i = PK * (n / PK); i <= n; ++i)
		{
			if(i % P) rem = rem * (i % PK) % PK;
		}
		return F(n / P, P, PK) * rou % PK * rem % PK;
	}
	ll G(ll n, ll P)
	{
		if(n < P) return 0;
		return G(n / P, P) + (n / P);
 	}
	ll C_PK(ll n, ll m, ll P, ll PK)
	{
		ll fz = F(n, P, PK), fm1 = INV(F(m, P, PK), PK), fm2 = INV(F(n - m, P, PK), PK);
		ll mi = qpow(P, G(n, P) - G(m, P) - G(n - m, P), PK);
		return fz * fm1 % PK *fm2 % PK * mi % PK;
	}
	ll A[1010], B[1010];
	ll solve(ll n, ll m, ll p)
	{
		ll lc = p, tot = 0;
		for(ll i = 2; i * i <= p; ++i)
		{
			if(!(lc % i)) 
			{
				ll PK = 1;
				while(!(lc % i))
				{
					PK *= i;
					lc /= i;
				}
				A[++tot] = PK; B[tot] = C_PK(n, m, i, PK);
			}
		}
		if(lc != 1)
		{
			A[++tot] = lc; B[tot] = C_PK(n, m, lc, lc);
		}
		ll ans = 0;
		for(ll i = 1; i <= tot; ++i)
		{
			ll M = p / A[i], T = INV(M, A[i]);
			ans = (ans + B[i] * M % p * T % p) % p;
		}
		return ans;
	}
}f;
void solve(int cas)
{
	ll n, m, p;
	cin >> n >> m >> p;
	cout << f.solve(n, m, p) << '\n';	
} 
```

```c++
/*
CRT+Lucas
计算模为多个素数乘积的组合数
模以m个素数形式给出
*/
namespace CRT_Lucas {
	ll f[N], rf[N];
	ll mul(ll x, ll y, ll P) {
		return (x * y - (ll)(x / (long double)P * y + 1e-3) * P + P) % P;
	}
	ll pow(ll a, ll b, ll P) {
		ll t = 1;
		for (; b; b >>= 1, a = mul(a, a, P))
			if (b & 1) t = mul(t, a, P);
		return t;
	}
	void Initialize(int n) {
		f[0] = 1;
		for (int i = 1; i < n; i++) f[i] = f[i - 1] * i % n;
		rf[n - 1] = pow(f[n - 1], n - 2, n);
		for (int i = n - 1; i; i--) rf[i - 1] = rf[i] * i % n;

	}
	ll C(int n, int m, int mod) {
		if (m > n || m < 0 || n < 0) return 0;
		return f[n] * rf[m] % mod * rf[n - m] % mod;
	}
	ll lucas(ll n, ll m, ll P) {
		if (n < m) return 0;
		if (!m || n == m) return 1;
		return C(n % P, m % P, P) * lucas(n / P, m / P, P) % P;
	}
	ll exgcd(ll a, ll b, ll& x, ll& y) {
		if (b == 0) {
		x = 1;
		y = 0;
		return a;
		}
		ll d = exgcd(b, a % b, y, x);
		y -= x * (a / b);
		return d;
	}
	ll CRT(ll* a, ll* b, int n) {
		ll P = 1, d, y, x = 0;
		for (int i = 0; i < n; i++) P *= a[i];
		for (int i = 0; i < n; i++) {
			ll w = P / a[i];
			exgcd(a[i], w, d, y);
			y = (y % P + P) % P;
			x = (x + mul(mul(y, w, P), b[i], P));
		}
		return (x + P) % P;
	}

	ll a[K], p[K];
	
	ll Cal(ll n, ll m, int k) {
		for (int i = 0; i < k; i++) {
		scanf("%lld", &p[i]);
		Initialize(p[i]);
		a[i] = lucas(n, m, p[i]);
		}
		return CRT(p, a, k);
	}
} // namespace CRT_Lucas
```



#### 康托展开

用来求排列的排名，时间复杂度$O(n \log n)$

#### 伪代码

```c++
int res = 1;
for(int i = 1; i <= n; ++i)
{
    res += (a[i] - 1 - cnt[比第i位数小且出现过的次数]) * （n - i)!;
}
```



#### 斐波那契数列

$$
F_{2*k}=F_k(2F_{k+1}-F_k)\\
F_{2*k+1}=F_{k+1}^2+F_k^2\\
F_{n-1}F_{n+1}-F_n^2=(-1)^n\\
F_{n+k}=F_kF_{n+1}+F_{k-1}F_n\\
F_{2*n}=F_n(F_{n+1}+F_{n-1})\\
F_n \mid F_{nk}\\
如果 F_a \mid F_b , 那么 a \mid  b\\
(F_m,F_n)=F_{(m,n)}
$$

每一个数都可以唯一的用斐波那契数和表示

模意义下具有周期性

#### 卢卡斯数列

$L_0=2,L_1=1$的广义斐波那契数列

#### 卡特兰数

$cat_n=\frac{1}{n+1}\tbinom{2*n}{n}$

#### 贝尔数

大小为$n$的集合划分为若干互不区分的集合的方案数B_{n+1}
$$
B_{n+1}=\sum_{i=0}^n \binom{n}{k} B_k
$$
生成函数
$$
f = exp(e^x-1)
$$


#### 斯特林数

#### 第一类斯特林数

#### 第二类斯特林数

#### 伯努利数



```c++
B[0] = 1;
for (int i = 1; i < MAXN; i++) {
    ll ans = 0;
    if (i == MAXN - 1) break;
    for (int k = 0; k < i; k++) {
        ans += C[i + 1][k] * B[k];
		ans %= mod;
    }
    ans = (ans * (-inv[i + 1]) % mod + mod) % mod;
    B[i] = ans;
}
```



#### 分拆数

#### 小球盒子

##### 模型1

$a$个白球，$b$个黑球，每次从中抽一个，抽到黑球停止。

##### 结论1

期望抽取白球的个数为$\frac{a}{b+1}$​

证明：

设$E(a,b)$为有$a$个白球，$b$个黑球的时候的抽取期望

则有$E(a+1,b)=\frac{a+1}{a+b+1} * (E(a,b) + 1)$

通过数学归纳法可以得出上述结论。

另一个简单证明：

相当于将$a$个物品分成$b+1$份，问第一份的期望长度，易知为$\frac{a}{b+1}$​

##### 结论2

大于$m$个时的期望长度是$\frac{a-m}{b+1}$

当$a<m$是为0

只要在白球中选择$m$个，然后剩下的再分成$b+1$份即可。



