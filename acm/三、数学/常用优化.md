## 常用优化
```c++
// 向下取整
r = n / (n / l);
// 向上取整
r = (n - 1) / ((n + l - 1) / l - 1);
//二维前缀和
return prefixSum[ex][ey] - prefixSum[bx - 1][ey]-prefixSum[ex][by - 1]+prefixSum[bx - 1][by - 1];
//平方和
n * (n + 1) * (2 * n + 1) / 6;
//有标号的树的数量
n^(n - 2)
//无标号的树的数量
Cat_n
//快速乘法
ll mul(ll x, ll y, ll mod)
{
    return (x * y - (ll)(x / (long double)mod * y + 1e-3) * mod + mod) % mod;
}
```



### 位运算

#### 返回x 的最后一位1 是从后向前第几位：

```c++
__builtin_ffs(unsigned x)
__builtin_ffsll(unsigned long long x)

__builtin_ffs(3) = 1
```


#### 返回 x 的二进制下前导的 0 的个数：


```c++
__builtin_clz(unsigned x)
__builtin_clzll(unsigned long long x)

__builtin_clz(4) = 29//int 
__builtin_clzll(4) = 61//long long 
```

#### 返回 x 的二进制下末尾的 0 的个数：

```c++
__builtin_ctz(unsigned x)
__builtin_ctzll(unsigned long long x)

__builtin_ctz(4) = 2
```

#### 返回 x 的二进制下 1 的个数

```c++
__builtin_popcount(unsigned x)
__builtin_popcountll(unsigned long long x)

__builtin_popcount(3) = 2
```

#### 返回 x 的二进制下 1 的个数的奇偶性

```c++
__builtin_parity(unsigned x)
__builtin_parityll(unsigned long long x)

__builtin_parity(3) = 0//偶数是 0 奇数是 1

```

#### 进制转换

```c++
itoa(int x,char *s ,int _radix)
itoa(3,a,2)
a="11"
```

#### 给定数组$a$，询问$x$,查询$max_{y \in a}(popcount (x \wedge y))$

##### 法1

$$
max_{y \in a}(popcount(x\wedge y)) = m - min_{y \in a}(popcount(x^c \wedge y))
$$

其中$x^c$是$x$的翻转$(0变1,1变0)$

然后就是最短路的问题

##### 法2

$$
popcount(x\wedge y) = popcount(x)+popcount(y) - 2 * popcount(x \& y)
$$

[COCI '22 Contest 5 #2 Diskurs 的题解 - DMOJ: Modern Online Judge](https://dmoj.ca/problem/coci22c5p2/editorial)

```c++
for(int S = 0; S < (1 << m); ++S) {
        f[S] = -m;
        if(b[S]) f[S] = __builtin_popcount(S);
        for(int i = 0; i < m; ++i) {
            if((1 << i) & S) f[S] = std::max(f[S], f[S ^ (1 << i)]);
        }
    }
    for(int S = (1 << m) - 1; S >= 0; --S) {
        dp[S] = f[S];
        for(int i = 0; i < m; ++i) {
            if(S & (1 << i)) continue;
            dp[S] = std::max(dp[S], dp[S | (1 << i)] - 2);
        }
    }
```



### 蒙哥马利模乘

#### 蒙哥马利约减

##### 看不懂

通常我们计算$xy \mod n$，我们需要$x*y-\lfloor \frac{x*y}{n} \rfloor  $

蒙哥马利模乘约减的思路是通过变换，将需要取模的数控制到很小的范围，最需要最多一次减法完成取模运算。通过选择除数为2的幂次，从而通过移位加快速度。

在竞赛范围(模数为正奇数)内，我们认为以下式子总会成立
$$
RR' \equiv 1 (\mod N)\\
RR' - NN' = 1\\
RR' - NN' \equiv 1 (\mod R) \\
-NN' \equiv 1 (\mod R) \\
0 < R' <N\\
0 <N'<R
$$
如果我们需要计算约减形式，即对于$T$我们想要求$TR'$
$$
T=T(RR'-NN')=TRR-TNN'\\
TR'=\frac{T+TNN'}{R}
$$
记$m=TN'$
$$
TR' \mod N \\
=\frac{T+mN}{R} \mod N \\
=\frac{T+(\lfloor \frac{T}{R} \rfloor R +(T\mod R))NN'}{R} \mod N \\
=\frac{T+(T\mod R)NN'}{R} +\lfloor \frac{T}{R} \rfloor NN' \mod N \\
=\frac{T+(T\mod R)NN'}{R}  \mod N \\
$$

##### 个人想法？

利用$exgcd$求$RR'-NN'=1$中的$R',N'$

约简的话，对于数$x$，计算$m = xN'(\mod R)$

```c++
template <std::uint32_t P>struct MontInt {
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	u32 v;
	static constexpr u32 get_r() {
		u32 iv = P;
 
        for (u32 i = 0; i != 4; ++i)
            iv *= 2U - P * iv;
 
        return -iv;
	}
    static constexpr u32 r = get_r(), r2 = -u64(P) % P;//限定词不能省 
    
	MontInt() = default;
    ~MontInt() = default;
    MontInt(u32 v) : v(reduce(u64(v) * r2)) {}
    MontInt(const MontInt &rhs) : v(rhs.v) {}
    
    u32 reduce(u64 x) {
        return x + (u64(u32(x) * r) * P) >> 32;
    }
    
    u32 norm(u32 x) {
        return x - (P & -(x >= P));
    }
    u32 get() {
        u32 res = reduce(v) - P;
        return res + (P & -(res >> 31));
    }
    
    
    MontInt operator-() const {
        MontInt res;
        return res.v = (P << 1 & -(v != 0)) - v, res;
    }
    MontInt inv() const {
        return pow(-1);
    }
    MontInt &operator=(const MontInt &rhs) {
        return v = rhs.v, *this;
    }
    MontInt &operator+=(const MontInt &rhs) {
        return v += rhs.v - (P << 1), v += P << 1 & -(v >> 31), *this;
    }
    MontInt &operator-=(const MontInt &rhs) {
        return v -= rhs.v, v += P << 1 & -(v >> 31), *this;
    }
    MontInt &operator*=(const MontInt &rhs) {
        return v = reduce(u64(v) * rhs.v), *this;
    }
    MontInt &operator/=(const MontInt &rhs) {
        return this->operator*=(rhs.inv());
    }
    friend MontInt operator+(const MontInt &lhs,
                                        const MontInt &rhs) {
        return MontInt(lhs) += rhs;
    }
    friend MontInt operator-(const MontInt &lhs,
                                        const MontInt &rhs) {
        return MontInt(lhs) -= rhs;
    }
    friend MontInt operator*(const MontInt &lhs,
                                        const MontInt &rhs) {
        return MontInt(lhs) *= rhs;
    }
    friend MontInt operator/(const MontInt &lhs,
                                        const MontInt &rhs) {
        return MontInt(lhs) /= rhs;
    }
    friend bool operator==(const MontInt &lhs, const MontInt &rhs) {
        return norm(lhs.v) == norm(rhs.v);
    }
    friend bool operator!=(const MontInt &lhs, const MontInt &rhs) {
        return norm(lhs.v) != norm(rhs.v);
    }
    constexpr MontInt pow(ll y) const {
        if ((y %= P - 1) < 0)
            y += P - 1; // phi(P) = P - 1, assume P is a prime number
 
        MontInt res(1), x(*this);
 
        for (; y != 0; y >>= 1, x *= x)
            if (y & 1)
                res *= x;
 
        return res;
    }
};
auto ans = MontInt<998244353>(i);
cout << ans.inv().get() << '\n';
```



```c++
/*

用于模为奇数且取模次数特别多的情况
UnsafeMod::set_mod(P) 初始化模数
x.get() 得到值
各种运算后取模直接运算即可
*/
typedef unsigned int uint32;
typedef long long int64;
typedef unsigned long long uint64;
typedef uint32 word;
typedef uint64 dword;
typedef int sword;
word mod;
struct UnsafeMod
{
    word x;
    UnsafeMod() : x(0) {}
    UnsafeMod(word _x) : x(init(_x)) {}
    UnsafeMod &operator+=(const UnsafeMod &rhs)
    {
        (x += rhs.x) >= mod && (x -= mod);
        return *this;
    }
    UnsafeMod &operator-=(const UnsafeMod &rhs)
    {
        sword(x -= rhs.x) < 0 && (x += mod);
        return *this;
    }
    UnsafeMod &operator*=(const UnsafeMod &rhs)
    {
        x = reduce(dword(x) * rhs.x);
        return *this;
    }
  
    UnsafeMod operator+(const UnsafeMod &rhs) const { return UnsafeMod(*this) += rhs; }
    UnsafeMod operator-(const UnsafeMod &rhs) const { return UnsafeMod(*this) -= rhs; }
    UnsafeMod operator*(const UnsafeMod &rhs) const { return UnsafeMod(*this) *= rhs; }
    word get() const { return reduce(x); }
    static word modulus() { return mod; }
    static word init(word w) { return reduce(dword(w) * r2); }
    static void set_mod(word m)
    {
        mod = m;
        Modinv = mul_inv(mod);
        r2 = -dword(mod) % mod;
    }
    static word reduce(dword x)
    {
        word y = word(x >> word_bits) - word((dword(word(x) * Modinv) * mod) >> word_bits);
        return sword(y) < 0 ? y + mod : y;
    }
    static word mul_inv(word n, int e = 6, word x = 1) { return !e ? x : mul_inv(n, e - 1, x * (2 - x * n)); }
} x, y;
```

### sqrtl

```c++
ll sqrtl(ll x)
{
    ll y = sqrt(x);
    while(y * y >= x) y--;
    while(y * y < x) y++;
    return y;
}
```

### 数值积分 自适应辛普森

```c++
double f(double x) //积分函数
{
    double temp=sin(x);
    return 1.0/(sqrt(temp*temp+3)-temp);
}
double Simpson(double l, double r)
{
    double m = (l + r) / 2;
    return (f(l) + 4 * f(m) + f(r)) * (r - l) / 6;
}
double cal(double l, double r, double res,double eps)
{
    double m = (l + r) / 2;
    double L = Simpson(l, m), R = Simpson(m, r);
    if (abs(L + R - res) <= 15 * eps) return L + R + (L + R - res) / 15;
    else return cal(l, m, L, eps / 2) + cal(m, r, R, eps / 2);
}
```

### GCD小常识

$$
GCD(Fib(n), Fib(m)) = GCD(Fib(n - m), Fib(m)) \\
GCD(a, b) = GCD(a - b, b) \\ 
如果GCD(a, b) == 1 \\
	那么GCD(a ^ m - b ^ m, a ^ n - b ^ n) = a ^ {GCD(m, n)} - b ^ {GCD(m, n)}
$$

### 矩阵快速幂

```c++
struct matrix
{
    vector<vector<mint>> a;
    int n;
    void init(vector<vector<mint>> &b)
    {
        a = b;
        n = a.size();
    }
    void init(int _n)
    {
        n = _n;
        a = vector<vector<mint>>(n, vector<mint>(n));
        for(int i = 0; i < n; ++i) a[i][i] = mint(1);
    }
    matrix &operator*=(const matrix &rhs)
    {
        vector<vector<mint>> ret(n, vector<mint>(n, 0));
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                for(int k = 0; k < n; ++k)
                {
                    ret[i][j] += a[i][k] * rhs.a[k][j];
                }
            }
        }
        a = ret;
        return *this;
    }
    void pr()
    {
        cout << n << '\n';
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                cout << a[i][j] << ' ';
            }
            cout << '\n';
        }
        cout << "==\n";
    }
    friend matrix operator*(const matrix &lhs, const matrix &rhs)
    {
        matrix res = lhs;
        res *= rhs;
        return res;
    }
    friend matrix qpow(matrix base, ll power)
    {
        matrix res; res.init(base.n);
        while (power) {
            if (power & 1) res = res * base;
            base = base * base;
            power >>= 1;
        }
        return res;
    }
};
matrix r; r.init(a);
auto res = qpow(r, b);
mint Ans = mint(0);
for(int i = 0; i < n; ++i)
{
    Ans += res.a[0][i] * rs[i];
}
```



