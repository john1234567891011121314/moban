## 常用优化
```c++
// 向下取整
r = n / (n / l);
// 向上取整
r = (n - 1) / ((n + l - 1) / l - 1);
//二维前缀和
return prefixSum[ex][ey] - prefixSum[bx - 1][ey]-prefixSum[ex][by - 1]+prefixSum[bx - 1][by - 1];
//平方和
n * (n + 1) * (2 * n + 1) / 6;
//有标号的树的数量
n^(n - 2)
//无标号的树的数量
Cat_n
//快速乘法
ll mul(ll x, ll y, ll mod)
{
    return (x * y - (ll)(x / (long double)mod * y + 1e-3) * mod + mod) % mod;
}
```



