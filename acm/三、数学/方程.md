## 方程
### 扩展中国剩余定理

考虑方程组
$$
x \equiv a_1 (\mod m_1)\\
x \equiv a_2 (\mod m_2)
$$
对于第一个方程，解的形式是$x = a_1 + k*m_1$。带入第二个方程得到$a_1 + k*m_1 = a_2(\mod m_2)$。用扩欧可以接出来一个$k_0$，那么我们就合并得到一个方程$x \equiv a_1 + k_0 *m_1(\mod lcm(m_1,m_2))$

```c++
	ll mul(ll a, ll b, ll c)
	{
		if(b < 0)a = -a, b = -b;
		ll res = 0;
		while(b)
		{
			if(b & 1)res = (res + a) % c;
			a = (a + a) % c;
			b >>= 1;
		}
		return res;
	}
vector<ll>ai,bi;//x mod b = a;
    ll excrt()
    {
    	int n = a.size();
    	ll x, y, k;
    	ll M = b[0], ans = a[0];//第一个方程的特解
    	for(int i = 1; i < n; ++i)
    	{
    		ll a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;
    		ll d = exgcd(a, b, x, y);
    		ll bg = b / d;	//lcm
    		if(c % d != 0)return -1;	//判断无解
    		x = mul(x, c / d, bg);
    		ans += x * M;	//更新前k个方程的答案
    		M *= bg;
    		ans = (ans % M + M) % M;
    	}
    	ans = (ans % M + M) % M;
        //if(ans == 0)ans = M; //看情况，可能0是符合题意的也可能不是
    	return ans;
    }
```

```c++
struct Congruence
{
	ll exgcd(ll a, ll b, ll &x, ll &y)	//扩欧
	{
		if(b == 0){x = 1; y = 0; return a;}
		ll d = exgcd(b, a % b, x, y);
		ll z = x; x = y; y = z - a / b * y;
		return d;
	}

	ll mul(ll a, ll b, ll c)
	{
		if(b < 0)a = -a, b = -b;
		ll res = 0;
		while(b)
		{
			if(b & 1)res = (res + a) % c;
			a = (a + a) % c;
			b >>= 1;
		}
		return res;
	}


	vector<ll>ai,bi;//x mod b = a;
    ll excrt()	//扩展中国剩余定理
    {
    	int n = ai.size();
    	ll x, y, k;
    	ll M = bi[0], ans = ai[0];//第一个方程的特解
    	for(int i = 1; i < n; ++i)
    	{
    		ll a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;
    		ll d = exgcd(a, b, x, y);
    		ll bg = b / d;	//lcm
    		if(c % d != 0)return -1;	//判断无解
    		x = mul(x, c / d, bg);
    		ans += x * M;	//更新前k个方程的答案
    		M *= bg;
    		ans = (ans % M + M) % M;
    	}
    	ans = (ans % M + M) % M;
    	// if(ans == 0)ans = M;	//看情况，可能0是符合题意的也可能不是
    	return ans;
    }
}t;
```



### 普通方程组

```c++
//0~n-1 -1表示无解，0表示无穷多解，1表示有唯一解
int Gauss(int n, vector<vector<double> > a, vector<double> b, vector<double> &x) //a是系数矩阵，b是等号右边的常数，x是返回的答案 
{
	x.resize(n, 0);
	int line = 0;
	for(int i = 0; i < n; ++i)
	{
		int p = line;
		for(int k = line + 1; k < n; ++k) if(fabs(a[k][i]) > fabs(a[p][i]))p = k;
		if(line != p) swap(a[p], a[line]), swap(b[line], b[p]);
		if(fabs(a[line][i]) < eps) continue;
		for(int k = 0; k < n; ++k)
		{
			if(k == line) continue;
			double d = a[k][i] / a[line][i];
			b[k] -= d * b[line];
			for(int j = i; j < n; ++j) a[k][j] -= d * a[line][j]; 
		}
		line++;
	}
	if(line < n)
	{
		while(line < n)
			if(fabs(b[line++]) > eps) return -1; 
		return 0;
	} 
	for(int i = n - 1; i >= 0; --i)
	{
		
		// for(int j = i + 1; j < n; ++j) b[i] -= x[j] * a[i][j];
		x[i] = b[i] / a[i][i]; 
		
	}
	return 1;
}
```

```c++
bool Gauss(int n, vector<vector<double> > a, vector<double> b, vector<double> &x) //a是系数矩阵，b是等号右边的常数，x是返回的答案 
{
	x.resize(n, 0);
	for(int i = 0; i < n; ++i)
	{
		int p = i;
		for(int k = i + 1; k < n; ++k) if(fabs(a[k][i]) > fabs(a[p][i]))p = k;
		if(i != p) swap(a[i], a[p]), swap(b[i], b[p]);
		if(a[i][i] == 0) return 0;
		for(int k = i + 1; k < n; ++k)
		{
			double d = a[k][i] / a[i][i];
			b[k] -= d * b[i];
			for(int j = i; j < n; ++j) a[k][j] -= d * a[i][j]; 
		}
	}
	for(int i = n - 1; i >= 0; --i)
	{
		
		for(int j = i + 1; j < n; ++j) b[i] -= x[j] * a[i][j];
		x[i] = b[i] / a[i][i]; 
		
	}
	return 1;
}
```

### 异或方程组

```c++
int gauss(int n)
{
	int row,col;
	for(row=1,col=1;col<=n;++col){
		int t = -1;
		for(int i=row;i<=n;++i){
			if(v[i][col]){
				t = i;
				break;
			}
		}
		if(t == -1) continue;
		if(t != row){
			for(int j=row;j<=n;j++) swap(v[row][j],v[t][j]);
		}
		for(int i=row+1;i<=n;i++){
			if(v[i][col]){
				for(int j=col;j<=n;j++)
					v[i][j] ^= v[row][j];
			}
		}
		row++;
	}
	return col-row;
}
```

### 高次同余方程、BSGS

可以有效解决此类查表问题$O(sqrt(n))$预处理，$O(sqrt(n))$查询

```c++
ll BSGS(ll a, ll b, ll P) //a^x=b(mod p) return x;
{
	map<ll, ll>mp;
	ll ans = 0, m = ceil(sqrt(P)) + 1, tmp = 1ll;
	for(ll i = 1; i <= m; ++i)
	{
		tmp = tmp * a % P;
		mp[tmp * b % P] = i;
		
	}
	ll res = tmp;
	for(ll i = 1; i <= m; ++i)
	{
		if(mp[res])
		{
			ans = m * i - mp[res];
			return ans;
		}
		res = res * tmp % P;
	}
	return -1;
}
```

### exgcd

```c++
ll exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b)
	{
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x; x = y; y = z - y * (a / b);
	return d;
} 
// ax = b (mod n)
ll get(ll a, ll b, ll n)
{
    ll x, y;
    ll d = exgcd(a, n, x, y);
    if(b % d) return -1; // 无解
    x = (x * (b / d)) % n;
    x = (x % (n / d) + n / d) % (n / d);// 最小整数解
    return x;
}
```



### exBSGS

解决a, p 不互质的情况

$a^x = b(\mod p)$

```c++
ll exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b)
	{
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x; x = y; y = z - y * (a / b);
	return d;
} 

using namespace std;

ll BSGS(ll a, ll b, ll P) //a^x=b(mod p) return x;
{
	b %= P, a %= P;
	map<ll, ll>mp;
	ll m = ceil(sqrt(P)) + 1, tmp = 1ll;
	for(ll i = 1; i <= m; ++i)
	{
		tmp = tmp * a % P;
		mp[tmp * b % P] = i;
		
	}
	ll res = tmp;
	for(ll i = 1; i <= m; ++i)
	{
		if(mp.find(res) != mp.end())
		{
			return (m * i - mp[res] + P) % P;
		}
		res = res * tmp % P;
	}
	return -1;
}
ll inv(ll a, ll b)
{
	ll x, y;
	exgcd(a, b, x, y);
	return (x % b + b) % b;
}
ll exBSGS(ll a, ll b, ll P) //a^x=b(mod p) return x;
{
	a %= P;
	b %= P;
	if(b == 1 || P == 1)
	{
		return 0;
	}
	ll g = gcd(a, P), k = 0, na = 1;
	while(g > 1)
	{
		
		if(b % g) return -1;
		k++; b /= g; P /= g; na = na * (a / g) % P;
		if(na == b) return k;
		g = gcd(a, P);
	}
	ll x, y;
	exgcd(na, P, x, y);
	x = (x % P + P) % P; 
	ll f = BSGS(a, b * x % P, P);
	if(f == -1)return -1;
	return f + k;
}
```

奇怪的求，似乎快很多$p≤10^{18}$ 且 $p $不怎么毒瘤能够通过

```c++
#include <bits/stdc++.h>
using namespace std;

// 2023 OneWan
long long qpow(long long a, long long b) {
	long long res = 1;
	while (b) {
		if (b & 1) res = res * a;
		a = a * a;
		b >>= 1;
	}
	return res;
}
long long qpow(long long a, long long b, long long mod) {
    long long res = 1;
    while (b) {
        if (b & 1) {
            res = (__int128) res * a % mod;
        }
        b >>= 1;
        a = (__int128) a * a % mod;
    }
    return res;
}
template<class T> struct Random {
    mt19937 mt;
    Random() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}
    T operator()(T L, T R) {
        uniform_int_distribution<int64_t> dist(L, R);
        return dist(mt);
    }
};
Random<long long> rng;
namespace Miller_Rabin {
    bool Miller_Rabin(const long long& n, const vector<long long>& as) {
        long long d = n - 1;
        while (!(d & 1)) {
            d >>= 1;
        }
        long long e = 1, rev = n - 1;
        for (auto& a : as) {
            if (n <= a) {
                break;
            }
            long long t = d;
            long long y = qpow(a, t, n);
            while (t != n - 1 && y != e && y != rev) {
                y = (__int128) y * y % n;
                t <<= 1;
            }
            if (y != rev && (!(t & 1))) return false;
        }
        return true;
    }
    bool is_prime(const long long& n) {
        if (!(n & 1)) {
            return n == 2;
        }
        if (n <= 1) {
            return false;
        }
        if (n < (1LL << 30)) {
            return Miller_Rabin(n, {2, 7, 61});
        }
        return Miller_Rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});
    }
} // Miller_Rabin
namespace Pollard_rho {
    long long solve(long long n) {
        if (!(n & 1)) {
            return 2;
        }
        if (Miller_Rabin::is_prime(n)) {
            return n;
        }
        long long R, one = 1;
        auto f = [&](long long x) {
            return ((__int128) x * x % n + R) % n;
        };
        auto rnd = [&]() {
            return rng(0, n - 3) + 2;
        };
        while (true) {
            long long x, y, ys, q = one;
            R = rnd(), y = rnd();
            long long g = 1;
            int m = 128;
            for (int r = 1 ; g == 1 ; r <<= 1) {
                x = y;
                for (int i = 0 ; i < r ; i++) {
                    y = f(y);
                }
                for (int k = 0 ; g == 1 && k < r ; k += m) {
                    ys = y;
                    for (int i = 0 ; i < m && i < r - k ; i++) {
                        q = (__int128) q * ((x - (y = f(y)) + n) % n) % n;
                    }
                    g = __gcd(q, n);
                }
            }
            if (g == n) {
                do {
                    g = __gcd((x - (ys = f(ys)) + n) % n, n);
                } while (g == 1);
            }
            if (g != n) {
                return g;
            }
        }
        return 0;
    }
    vector<long long> factorize(long long n) {
        if (n <= 1) return {};
        long long p = solve(n);
        if (p == n) return {n};
        auto L = factorize(p);
        auto R = factorize(n / p);
        copy(R.begin(), R.end(), back_inserter(L));
        return L;
    }
    vector<pair<long long, int>> prime_factor(long long n) {
        auto ps = factorize(n);
        sort(ps.begin(), ps.end());
        vector<pair<long long, int>> ret;
        for (auto &e : ps) {
            if (!ret.empty() && ret.back().first == e) {
                ret.back().second++;
            } else {
                ret.emplace_back(e, 1);
            }
        }
        return ret;
    }
    vector<long long> divisors(long long n) {
        auto ps = prime_factor(n);
        int cnt = 1;
        for (auto& [p, t] : ps) cnt *= t + 1;
        vector<long long> ret(cnt, 1);
        cnt = 1;
        for (auto& [p, t] : ps) {
            long long pw = 1;
            for (int i = 1; i <= t; i++) {
                pw *= p;
                for (int j = 0; j < cnt; j++) ret[cnt * i + j] = ret[j] * pw;
            }
            cnt *= t + 1;
        }
        return ret;
    }
} // Pollard_rho
namespace Pohlig_Hellman {
	long long BSGS(long long A, long long B, long long P, long long mod) {
		A %= mod;
		B %= mod;
		if (B == 1) {
			return 0;
		}
		if (A == 0) {
			if (B == 0) {
				return 1;
			}
			return -1;
		}
		long long t = 1;
		int m = sqrt(1.0 * P) + 1;
		long long base = B;
		unordered_map<long long, long long> vis;
		for (int i = 0 ; i < m ; i++) {
			vis[base] = i;
			base = (__int128) base * A % mod;
		}
		base = qpow(A, m, mod);
		long long now = 1;
		for (int i = 1 ; i <= m ; i++) {
			now = (__int128) now * base % mod;
			auto k = vis.find(now);
			if (k != vis.end()) {
				return i * m - k -> second;
			}
		}
		return -1;
	}
	long long getK(long long A, long long B, long long P, long long C, long long phi, long long mod) {
		vector<long long> pi;
		long long temp = 1;
		for (int i = 0 ; i <= C ; i++) {
			pi.emplace_back(temp);
			temp *= P;
		}
		long long k = qpow(A, pi[C - 1], mod);
		long long inv = 0;
		temp = 1;
		for (int i = C - 1 ; i >= 0 ; i--) {
			long long tp = qpow(A, pi[C] - inv, mod);
			long long tx = temp * BSGS(k, qpow((__int128)B * tp % mod, pi[i], mod), P, mod);
			inv += tx;
			temp *= P;
		}
		return inv;
	}
	int getOrg(long long P, long long phi, const vector<pair<long long, int>>& res) {
		for (int k = 2 ; ; k++) {
			bool flag = true;
			for (auto& [x, y] : res) {
				if (qpow(k, phi / x, P) == 1LL) {
					flag = false;
					break;
				}
			}
			if (flag) return k;
		}
	}
	void Exgcd(long long a, long long b, long long& x, long long& y) {
		if (b == 0) {
			x = 1;
			y = 0;
			return;
		}
		Exgcd(b, a % b, y, x);
		y -= a / b * x;
	}
	long long CRT(const vector<long long>& k, const vector<pair<long long, int>>& res) {
		int len = res.size();
		long long M = 1, ans = 0;
		vector<long long> m(len);
		for (int i = 0 ; i < len ; i++) {
			m[i] = qpow(res[i].first, res[i].second);
			M *= m[i];
		}
		for (int i = 0 ; i < len ; i++) {
			long long Mi = M / m[i];
			long long x, y;
			Exgcd(Mi, m[i], x, y);
			ans = (ans + (__int128)Mi * ((x % m[i] + m[i]) % m[i]) * k[i]) % M;
		}
		if (ans < 0) ans += M;
		return ans;
	}
	long long getX(long long B, long long A, long long phi, long long mod, vector<pair<long long, int>>& res) {
		vector<long long> k;
		for (auto& [x, y] : res) {
			long long z = qpow(x, y);
			long long tA = qpow(A, phi / z, mod);
			long long tB = qpow(B, phi / z, mod);
			k.emplace_back(getK(tA, tB, x, y, phi, mod));
		}
		return CRT(k, res);
	}
	long long Solve(long long A, long long B, long long P) {
		if (B == 1LL) {
			return 0LL;
		}
		long long phi = P - 1;
		vector<pair<long long, int>> res = Pollard_rho::prime_factor(phi);
		int rt = getOrg(P, phi, res);
		long long x = getX(A, rt, phi, P, res), y = getX(B, rt, phi, P, res);
		long long a, b;
		if (x == 0LL) {
			if (y == 0LL) {
				return 1LL;
			} else if (y == 1LL) {
				return 0LL;
			}
			return -1LL;
		}
		long long d;
		if (y % (d = __gcd(x, phi))) return -1;
		x /= d;
		phi /= d;
		y /= d;
		Exgcd(x, phi, a, b);
		a = ((__int128)a * y % phi + phi) % phi;
		return a;
	}
} // Pohlig_Hellman

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	long long A, B, P;
	cin >> P >> A >> B;
	long long ans = Pohlig_Hellman::Solve(A, B, P);
	if (ans == -1) {
		cout << "no solution\n";
	} else {
		cout << ans << "\n";
	}
	return 0;
}
```

### 二次剩余

已知原根，也可以使用BSGS来求

```c++
ll mul(ll x, ll y, ll P) {
	return	(x * y - (ll)(x / (long double)P * y + 1e-3) * P + P) % P;
}

ll pow_mod(ll a, ll b, ll P) {
	ll t = 1;
	for (; b; b >>= 1, a = mul(a, a, P))
	if (b & 1) t = mul(t, a, P);
	return t;
}
ll tonelli_shanks(ll x, const ll p) { // 假设 p 为奇素数，计算 x^{1/2}
    if (x <= 1) return x;
    if (qpow(x, p >> 1, p) != 1) return -1; // p >> 1 即 (p - 1) / 2 ，欧拉准则判断，只有是1才有解
    if ((p & 3) == 3) return qpow(x, (p + 1) >> 2, p); // 特殊情况，p mod 4 = 3
    ll r = 0, s = p - 1;                              // 2^r * s = p - 1
    while ((s & 1) == 0) ++r, s >>= 1;

    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<ll> dis(2, p - 1);

    ll v; // 随机找一个 v 为二次非剩余
    for (; qpow(v = dis(gen), p >> 1, p) == 1;);

    ll w = qpow(v, s, p); // w = v^s

    ll t = 0;
    ll ix = qpow(x, p - 2, p);                      // ix = x^{-1}
    x = qpow(x, (s + 1) >> 1, p);                       // x = x^{(s+1)/2}
    ll y = x * x % p * ix % p; // y = x^s
    for (; qpow(y, 1 << t, p) != 1; ++t) {            // 2^t = ord(x^s) ，计算 t0
    }
    while (t != 0) {
        x = x * qpow(w, 1 << (r - t - 1), p) % p;
        y = x * x % p * ix % p;
        for (--t; t != 0 && qpow(y, 1 << (t - 1), p) == 1; --t) {
        }
    }
    return x;
}
void solve()
{
    ll n, p; cin >> n >> p;
    ll res = tonelli_shanks(n, p);
    if(res == -1)
    {
        cout << "Hola!\n";
    }
    else 
    {
        if(res == 0) cout << 0 << '\n';
        else cout << min(res, p - res) << ' ' << max(p - res, res) << '\n';
    }
}
```



### 线性规划

$$
\max \sum b_i \times y_i \\
\sum a_{i,j} \times y_j \leq c_i \\
y_i \geq 0
$$

无约束相减

```c++
int n, m;
double a[M][N], b[M], c[N], v;

void pivot(int l, int e)
{ // 转轴操作函数
    b[l] /= a[l][e];
    for (int j = 1; j <= n; j++)
        if (j != e)
            a[l][j] /= a[l][e];
    a[l][e] = 1 / a[l][e];

    for (int i = 1; i <= m; i++)
        if (i != l && fabs(a[i][e]) > 0)
        {
            b[i] -= a[i][e] * b[l];
            for (int j = 1; j <= n; j++)
                if (j != e)
                    a[i][j] -= a[i][e] * a[l][j];
            a[i][e] = -a[i][e] * a[l][e];
        }

    v += c[e] * b[l];
    for (int j = 1; j <= n; j++)
        if (j != e)
            c[j] -= c[e] * a[l][j];
    c[e] = -c[e] * a[l][e];

    // swap(B[l],N[e])
}

double simplex()
{
    while (true)
    {
        int e = 0, l = 0;
        for (e = 1; e <= n; e++)
            if (c[e] > (double)0)
                break;
        if (e == n + 1)
            return v; // 此时v即为最优解
        double mn = INF;
        for (int i = 1; i <= m; i++)
        {
            if (a[i][e] > (double)0 && mn > b[i] / a[i][e])
            {
                mn = b[i] / a[i][e]; // 找对这个e限制最紧的l
                l = i;
            }
        }
        if (mn == INF)
            return INF; // unbounded
        pivot(l, e);    // 转动l,e
    }
}
```



