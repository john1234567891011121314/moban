## 常见博弈
### bash博弈

$n$个石子，每次可以取$1-m$颗石子

#### 必败必胜

$n\mod (m+1)==0$先手必败，否则先手必胜

当$n\leq m $时，甲可以一次性拿完。先手必胜

$n=m+1$时，甲无论如何都拿不完，乙可以在甲操作完后拿完，先手必败。

$n$是$m+1$的倍数时，无论怎么拿都会破坏这个状态，后者总可以回到这个状态。

#### 变种

每次我们只能取$\{a_1,a_2,\cdots,a_k\}$这个集合中的石子数

通常我们可以打表找规律，也可以$sg$函数判断，一般来说都有周期性。

### NIM博弈

有$n$堆石子，每次从某一堆中取任意数量的石子。

#### 必败

当$a_1 \oplus  a_2 \oplus a_3 \oplus \cdots \oplus a_n ==0 $，先手必败，否则先手必胜

我们一定可以从必胜态找到一个必败态的后继，而必败态找不到必败态的后继。

### 威佐夫博弈

有两堆石子，每次可以从一堆中拿任意数量的石子或者从两堆中拿走相同数量的石子。

#### 必败

当且仅当当前局势为奇异局势时必败

```c++
bool Wythoff(int n,int m){
     if(n<m) swap(n,m);
     int k=n-m;
     n=(int)(k*(1+sqrt(5))/2.0);
     if(n==m)return 0;
     else return 1;
}
```



### 反尼姆博弈

n堆石子, 双方轮流从任意一堆石子中取出至少一个, 不能取的一方获胜 

#### 先手必胜

 1.所有堆的石子数都为1且游戏的SG值为0； 

2.有些堆的石子数大于1且游戏的SG值不为0。

### 阶梯博弈

有N堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。 两人轮流操作每次操作可以从一堆石子中移走任意多石子， 但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。 

Solution： 我们定义最后一堆以及下标与其相差为偶数的堆为偶堆石子，其余的为奇堆石子， 我们发现不管奇堆石子做什么操作，只要在偶堆石子中做相应的操作就可以抵消， 因此决定这个游戏胜负的是奇堆石子和后一个偶堆石子之间的差值， 其差值序列等同于NIM游戏，因此求出其sg值即可。

```c++
for(int i=n;i;i--)if(!((n-i)&1))sg^=(a[i]-a[i-1]);
 puts(sg?"TAK":"NIE");
```

### nimk游戏

 Nimk游戏: n堆石子，每人一次可以从最多m堆石子中取出每堆至多k个，不能取的人输. 

策略： 在二进制下各堆石子的sg函数均为(m+1)的倍数的话则为必败态, 否则为必胜态.

```c++
for(int i=0;i<n;i++)for(int j=0,g=a[i]%(k+1);sg[j]+=g&1,g;j++,g>>=1);
 for(int i=0;i<30;i++)if(sg[i]%(m+1))return 1;
 return 0;
```



