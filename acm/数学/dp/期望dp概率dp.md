## 期望$dp$

### 常用公式

$$
E(X)=\sum p(X_i)X_i \\
E(X|D) =\sum p(X_i|D)X_i\\
P(X|D)=\frac{P(XD)}{P(D)} \\
P(A)=\sum P(A|B_i)P(B_i) ,~~~B_i \cap B_j= \emptyset, ~~ \cup B_i=\Omega
$$

**通常我们期望$dp$是从后往前推，而概率$dp$一般从前往后**

**期望具有线性性**

## 题目

### 题意

$n$面的骰子，问每个面都被投出过的期望次数是多少

### 分析

$dp[i]$表示已经有$i$面被投出过，那么接下来还有$n-i$没有被投出过
$$
dp[i] = \frac{i}{n}dp[i]+\frac{n-i}{n}dp[i+1]+1
$$
稍作整理即可得出递推式

### 题意

若干个宝箱，宝箱里有东西的概率是$p$，求最后$n$次中至少有$k$个宝箱期望次数

### 分析

这题$n$，$k$很小，只有$6$

考虑枚举最后$n$位的状态，我们有
$$
dp[z_0z_1z_2z_3z_4z_5]=1+p*dp[1z_0z_1z_2z_3z_4]+(1-p)*dp[0z_0z_1z_2z_3z_4]
$$
然后高斯消元即可

### 题意

已知牌堆一共有34种类型，每种类型的牌四张

在开局会发给你13张牌，（**保证**每种类型的牌的数量小于等于2)，以此进行游戏

在每一回合，先从牌库抽一张牌，若此时十四张手牌为（7种不同的类型，每种各两张）则算作胜利，结束游戏。否则就从十四张牌中选择一张放入弃牌堆（不放回的意思）

一共T组样例，每次给你起始手牌，询问在**最优策略的情况下**的获胜的期望次数。

### 分析

首先思考什么是最优策略

如果我当前拿到的牌，我手中已经有了2张，那么我们就直接丢弃这张牌

如果我当前已经有一张，那么我们丢弃另外的只有一张的牌

如果我当前没有，那么直接把这张牌丢了

为什么呢，首先我一开始手上一定有单牌，那么最后我们肯定是和一开始留下的牌进行匹配，不然如果我们先前把某个类型的牌丢了，那么后面我们就不可能再拿这个类型的牌，因为牌库里这种牌的数量已经小于$3$了，比一开始就有的牌抽到的概率低。

于是我们发现每次我只需要关心牌库里还有几张牌，以及我当前有几张单牌。

于是设$dp[i][j]$表示牌库里还有$j$张牌，手上有$i$张单牌，然后到达全匹配的期望次数。

容易发现$dp[1][3]=1$。即当我手上有只有一张单牌，同时牌库里还有三张牌时，我们怎么样都可以抽出一个

和其匹配的牌。

同时我们有转移方程
$$
dp[i][j]=1+\frac{3*i}{j}dp[i-2][j-1]+\frac{j-3*i}{j}dp[i][j-1]
$$
这里$-2$是因为还有一张牌被我们丢了

当$i$等于1时，我们有
$$
dp[i][j]=1+\frac{j-3*i}{j}dp[i][j-1]
$$
这是因为只有我们没抽到想要的牌，我们才需要继续抽

### 题意

一个长度为$n$的序列，每次操纵随机选取两个下标，然后将这两个下标对应的数进行交换，问$m$次操作后每一位和一开始不同的个数的期望

### 分析

一道很好的期望题，虽然赛时尝试打表并没有找到什么规律

我们计$f_m$表示操作%$m$次后，$a_0=0$的概率。

因为每一位其实是等价的，我们计算时可以

$E(\sum X_i) =\sum E(X_i)=n*E(X_0)=n*f_m$

其中$E(X_i)$表示第$i$位和一开始一样的期望

因此只需要计算$f_m$即可

首先第$m$次和原来相同，来自于前一次和原来相同，然后操作一次不变，或者前一次和原来不同，但是操作完后回到原位置

原来相同，操作不变，可能是两次交换的下标都是$0$，或者都不是$0$

原来不同，那么只有两种情况回到原位置

$f_m= \frac{1+(n-1)^2}{n^2} f_{m-1} + \frac{2}{n^2} (1-f_{m-1})$

化简得到$f_m=\frac{2}{n^2}+\frac{n-2}{n}f_{m-1}$

然后就可以用矩阵快速幂之类的方法维护了。

## 随机游走

 首先对于任何一个点的期望经过次数，我们都有

$d(x)$表示点$x$的度
$$
E(X)= \sum_{X \to Y} \frac{E[Y]}{d(Y)}
$$
而每条边经过的期望次数我们可以写成
$$
f(u,v)=\frac{E(u)}{d(u)}+\frac{E(v)}{d(v)}
$$
然后通过高斯消元我们就可以解决问题

### 树上随机游走

不妨计$f[i]$为从子节点$i$走向父节点的期望步数，我们有


$$
f[u]=\frac{w(u,p_u)+\sum_{v \in son_u} (w(u,v)+f[v]+f[u])}{deg[u]}
$$
化简可得
$$
f[u]=\sum_{(u,v) \in E} w(u,v) + \sum_{v \in son_u}f[v]
$$
当边权都是1时，我们进一步可以得到
$$
f[u]=2*size[u]-1
$$
其中$size[u]$是$u$子树的大小

计$G[x]$为从父节点$f$走向子节点$x$的期望步数
$$
G[x]=\frac{w(p_x,x) + (~ w(p_x,p_{p_x})+ G[p_x]+G[x] ~) + \sum_{v \in son_{f_x},v \neq x } (~w(p_x,v)+f[v] + G[x]) } {deg[p_x]}
$$
化简可得
$$
G[x]=G[p_x] + f[p_u] - f[u]
$$

```c++
//代码存疑需要修改，主要初始值需要斟酌
void dfs1(int u, int p) {
    bool flag = 1;
  	for (auto [v,w] : G[u]) {
    	if (v == p) continue;
        flag = 0;
    	dfs1(v, u);
    	f[u] += f[v] + w;
  	}
    if(flag) f[u] = G[u][0].second; 
}

void dfs2(int u, int p) {
  	for (auto v : G[u]) {
    	if (v == p) continue;
        g[v] = g[u] + f[u] - f[v];
    	dfs2(v, u);
    	
  	}
}
```

