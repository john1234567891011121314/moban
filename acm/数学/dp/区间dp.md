# 题目

## 题意

你有$n$张牌，每张牌都有类型和等级$(初始等级为1)$，每张牌打出去后都会产生$p^{x-1}*V_i$的收益，其中$x$是这张牌的等级，$i$是这张牌的种类。你可以选择两张相邻且种类相同等级相同的牌，将其合并为一张更高等级的牌，求所有牌打完后的最高收益。

## 分析

这显然是一道区间$dp$，即我们可以考虑这个区间产生的最大收益是多少。但是仅有这个状态是不够的，因为还有合并的状态，因此我们考虑这个区间只有一张牌的情况，此时任意的合并操作都可以看成两个区间留下一张牌的情况

即设状态为$dp[l][r][x][k]$，表示在$[l,r]$区间保留种类为$k$，等级为$x$的牌。

同时记$dp[l][r][0][0]$，表示这个区间牌都打光的情况。

如果留下来的牌等级为$1$，那么
$$
dp[l][r][1][k]=\max_{l+1 \leq p \leq r-1,a[i]==k} (dp[l][p-1][0][0]+dp[p+1][r][0][0])
$$
同时，$p=l$或$p=r$的情况与之类似

如果留下的牌等级超过$1$，那么一定是合成来的
$$
dp[l][r][x][k]=\max_{l\leq p\leq r-1} (dp[l][p][x-1][k]+dp[p+1][r][x-1][k])
$$
计算这个区间的贡献，只需枚举这个区间最后一张牌是是什么
$$
dp[l][r][0][0]=\max{dp[l][r][x][k]+P^{x-1}*v[k]}
$$

```c++
for(int i=0;i<=n;++i)for(int p=0;p<=n;++p)
        for(int j=0;j<=7;++j)for(int k=0;k<=20;++k)dp[i][p][j][k]=-LINF;
    
    for(int i=1;i<=n;++i)dp[i][i][1][a[i]]=0,dp[i][i][0][0]=v[a[i]];
    for(int len=2;len<=n;++len)
    {
        for(int l=1;l+len-1<=n;++l)
        {
            int r=l+len-1;
            for(int p=l;p<=r;++p)
            {
                if(p!=l&&p!=r)dp[l][r][1][a[p]]=max(dp[l][r][1][a[p]],dp[l][p-1][0][0]+dp[p+1][r][0][0]);
                else if(p==l)dp[l][r][1][a[p]]=max(dp[l][r][1][a[p]],dp[p+1][r][0][0]);
                else if(p==r)dp[l][r][1][a[p]]=max(dp[l][r][1][a[p]],dp[l][p-1][0][0]);
            }
            
            for(int x=2;x<=R;++x)
            {
                for(int k=1;k<=m;++k)
                {
                    for(int p=l;p<r;++p)
                    {
                        dp[l][r][x][k]=max(dp[l][r][x][k],dp[l][p][x-1][k]+dp[p+1][r][x-1][k]);
                    }
                }
                
            }
            
            for(int x=1;x<=R;++x)
            {
                for(int k=1;k<=m;++k)
                {
                    dp[l][r][0][0]=max(dp[l][r][0][0],dp[l][r][x][k]+v[k]*pw[x-1]);
                }
            }
        }
    }
    cout<<dp[1][n][0][0]<<'\n';
```

