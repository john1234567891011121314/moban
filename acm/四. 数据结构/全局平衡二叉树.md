## 全局平衡二叉树
### 单点修改

```c++
struct mat
{
    int mp[2][2];
    mat()
    {
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j)
                mp[i][j] = -INF;
    }
    mat(int a, int b, int c, int d)
    {
        mp[0][0] = a;
        mp[0][1] = b;
        mp[1][0] = c;
        mp[1][1] = d;
    }
    friend mat operator*(const mat &a, const mat &b)
    {
        mat c;
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j)
                for (int k = 0; k < 2; ++k)
                    c.mp[i][j] = max(c.mp[i][j], a.mp[i][k] + b.mp[k][j]);
        return c;
    }
};
int w[N];
struct Bst
{
    int root;             // 平衡后的根
    int dep[N], son[N], sz[N];
    int tfa[N];
    int ls[N], rs[N];
    int st[N], tp;
    bitset<N> vis;
    int s[N];
    mat val[N], d[N]; // 记录非重儿子的矩阵和所有儿子的转移矩阵信息
    vector<int> G[N];
    void add(int x, int y)
    {
        G[x].push_back(y);
        G[y].push_back(x);
    }

    // 找重儿子
    void dfs(int u, int fa)
    {
        sz[u] = 1;
        for (int v : G[u])
        {
            if (v == fa)
                continue;
            dep[v] = dep[u] + 1;
            dfs(v, u);
            sz[u] += sz[v];
            if (!sz[u] || sz[son[u]] < sz[v])
                son[u] = v;
        }
    }

    void update(int u)
    {
        d[u] = val[u];
        if (ls[u])
            d[u] = d[ls[u]] * d[u];
        if (rs[u])
            d[u] = d[u] * d[rs[u]];
    }
    // 链分治
    int Sbuild(int l, int r)
    {
        if (l > r)
            return 0;
        int mid = lower_bound(s + l, s + r + 1, (s[r] + s[l - 1]) >> 1) - s;
        int lch = Sbuild(l, mid - 1), rch = Sbuild(mid + 1, r);
        ls[st[mid]] = lch, rs[st[mid]] = rch;
        tfa[lch] = tfa[rch] = st[mid];
        update(st[mid]);
        return st[mid];
    }
    // 构建平衡树
    int build(int u)
    {
        for (int pos = u; pos; pos = son[pos])
            vis[pos] = true;
        // 计算轻儿子的贡献
        for (int pos = u; pos; pos = son[pos])
            for (int v : G[pos])
                if (!vis[v])
                {
                    tfa[build(v)] = pos;
                    while (tfa[v] != pos)
                        v = tfa[v];

                    val[pos].mp[0][0] += max(d[v].mp[0][0], d[v].mp[1][0]);
                    val[pos].mp[0][1] = val[pos].mp[0][0];
                    val[pos].mp[1][0] += d[v].mp[0][0];
                }
        // 处理重儿子
        tp = 0;
        for (int pos = u; pos; pos = son[pos])
        {
            st[++tp] = pos; // 把重链取出来
            s[tp] = s[tp - 1] + sz[pos] - sz[son[pos]];
        }
        int ret = Sbuild(1, tp); // 对重链进行单独的SBuild
        return ret;              // 返回当前重链的二叉树的根
    }

    void Modify(int u, int v)
    {
        // 更新矩阵
        val[u].mp[1][0] += v - w[u];
        w[u] = v;
        for (int pos = u; pos; pos = tfa[pos])
            if (tfa[pos] && ls[tfa[pos]] != pos && rs[tfa[pos]] != pos)
            {
                mat c1 = d[pos];
                update(pos);
                mat c2 = d[pos];
                val[tfa[pos]].mp[0][0] += max(c2.mp[0][0], c2.mp[1][0]) - max(c1.mp[0][0], c1.mp[1][0]);
                val[tfa[pos]].mp[0][1] = val[tfa[pos]].mp[0][0];
                val[tfa[pos]].mp[1][0] += c2.mp[0][0] - c1.mp[0][0];
            }
            else
                update(pos);
    }

    void work()
    {
        // d[0] = mat(0, 0, -INF, -INF);
        dfs(1, -1);
        root = build(1);
    }

    int query()
    {
        int ret = -INF;
        for (int i = 0; i < 2; ++i)
            for (int j = 0; j < 2; ++j)
                ret = max(ret, d[root].mp[i][j]);

        return max(d[root].mp[0][0], d[root].mp[1][0]);
    }
} bs;

void solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
    {
        cin >> w[i];
        bs.val[i] = mat(0, 0, w[i], -INF);
    }
    for (int i = 1; i < n; ++i)
    {
        int x, y;
        cin >> x >> y;
        bs.add(x, y);
        // bs.add(y, x);
    }
    bs.work();

    int lastAns = 0;

    while (m--)
    {
        int u, v;
        cin >> u >> v;
        u ^= lastAns;
        bs.Modify(u, v);
        lastAns = bs.query();
        cout << lastAns << '\n';
    }
}
```



