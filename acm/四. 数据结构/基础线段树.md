## 基础线段树
注意开四倍空间

几个可能的优化：

1. 叶子节点可以不用下放$lazy$标记
2. 标记永久化

```c++
//区间加，区间询问 
struct SegTree{
	ll val[N<<2];
	ll lazy[N<<2];
	int n = 0;
	void push_up(int p)
	{
		val[p] = val[p << 1] + val[p << 1 | 1];
	}
	void push_down(int p)
	{
		if(lazy[p])
		{
			int mid = (l + r) >> 1;
			val[p << 1] += lazy[p] * (mid - l + 1);
			val[p << 1 | 1] += lazy[p] * (r - mid);
			lazy[p << 1] += w;
			lazy[p << 1 | 1] += w;
			lazy[p] = 0;
		}
	}
	void build(int p,int l,int r)
	{
		if(p == 1) n = r;
		if(l==r)
		{
			val[p] = a[l];
			return ;
		}
		int mid = (l + r) >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		push_up(p);
	}	
	void add(int p,int ql, int qr, ll w, int l = 1,int r = n)
	{
		if(ql <= l && r <= qr)
		{
			lazy[p] += w;
			val[p] += w * (r - l + 1);
			return ;
		}
		push_down(p, l, r);
		int mid = (l + r) >> 1;
		if(ql <= mid) add(p << 1, ql, qr, l, mid);
		if(qr > mid) add(p <<< 1 | 1, ql, qr, mid + 1, r);
		push_up(p);
	}
	ll query(int p, int ql, int qr, int l = 1, int r = n)
	{
		if(ql <= l && r <= qr)
		{
			return val[p];
		}
		push_down(p, l, r);
		int mid = (l + r) >> 1;
		ll ans = 0;
		if(ql <= mid) ans += query(p << 1, ql, qr, l, mid);
		if(qr > mid) ans += query(p <<< 1 | 1, ql, qr, mid + 1, r);
		return ans;
	}
}; 
```

求矩形面积并

```c++
int x[N << 1];
int tr[N << 2];
int len[N << 2], rs[N << 2];
void build(int p, int l, int r)
{
    tr[p] = len[p] = 0;
    if(l == r)
    {
        rs[p] = x[r + 1] - x[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    rs[p] = rs[p << 1] + rs[p << 1 | 1];
}
void update(int p, int l, int r, int ql, int qr, int val)
{
    // if(qr < ql) return ;
    if(ql <= l && r <= qr)
    {
        tr[p] += val;
        if(tr[p]) len[p] = rs[p];
        else if(l == r) len[p] = 0;
        else len[p] = len[p << 1] + len[p << 1 | 1];
        return ;
    }   
    int mid = (l + r) >> 1;
    if(ql <= mid) update(p << 1, l, mid, ql, qr, val);
    if(qr > mid) update(p << 1 | 1, mid + 1, r, ql, qr, val);

    if(tr[p]) len[p] = rs[p];
    else if(l == r) len[p] = 0;
    else len[p] = len[p << 1] + len[p << 1 | 1];

}
struct ndoe
{
    int l, r, x;
    int val;
    bool operator<(const ndoe& a) const
    {
        return x < a.x;
    }
} a[N << 1];
void solve()
{
    int n; cin >> n;
    for(int i = 1; i <= n; ++i)
    {
        int l, d, r, u;
        cin >> l >> d >> r >> u;
        if(l == r || d == u)
        {
            i--, n--;
            continue;
        }
        x[2 * i - 1] = l;
        x[2 * i] = r;
        a[2 * i - 1] = {l, r, d, 1};
        a[2 * i] = {l, r, u, -1};

    }
    sort(x + 1, x + 2 * n + 1);
    sort(a + 1, a + 2 * n + 1);
    int tot = unique(x + 1, x + 2 * n + 1) - x - 1;
    build(1, 1, tot - 1);
    ll ans = 0;
    for(int i = 1; i < 2 * n; ++i)
    {
        int tl = lower_bound(x + 1, x + tot + 1, a[i].l) - x;
        int tr = lower_bound(x + 1, x + tot + 1, a[i].r) - x;
        update(1, 1, tot - 1, tl, tr - 1, a[i].val);
        ans += (a[i + 1].x - a[i].x) * len[1];
    }
    cout << ans << '\n';
}
```



