## 李超树
李超树是在线维护平面线段在整点取值这类问题的结构

抽象的说，应该具有两个功能

1. 加入一条线段
2. 给定数$k$，询问与直线$x=k$相交的线段中，纵坐标最大的线段的标号，坐标相同我们取编号最小的

由于每次询问的点都是整数，因此对于某个区间，我们可以考虑维护最大的线段。

但是线段具有方向性，我们只能保证某一个点只有一个线段是最大的，但是区间上的情况就比较复杂。因此我们利用标记永久化的方法，在询问时，将所有含这个点的线段都找出来然后取最大

时间复杂度，插入为$O(\log^2n)$，查询为$O(\log n)$。

```c++
int cmp(double x, double y)
{
	if(fabs(x - y) < eps) return 0;
	if(x - y > eps) return 1;
	return -1;
}
//小于0记得改l[0]的值 
struct node
{
	double k,b;
}l[N];
int tot;
void add(int x0, int y0, int x1, int y1)
{
	tot++;
	if(x0 == x1)
	{
		l[tot].k = 0;
		l[tot].b = max(y0,y1);
	}
	else
	{
		l[tot].k = (double)(y1 - y0) / (x1 - x0);
		l[tot].b = y0 - l[tot].k * x0;
	}
}
double calc(int id,int x)
{
	return l[id].b + l[id].k * x;
}
int s[N << 2];
void udp(int p, int l, int r, int id)
{
	int &v = s[p], mid = (l + r) >> 1;
	int ckmid = cmp(calc(id, mid), calc(v, mid));
	if(ckmid == 1 || (ckmid == 0 && id < v)) swap(v,id);
//	if(l == r) return ;
	int lcheck = cmp(calc(id, l), calc(v, l)), rcheck = cmp(calc(id, r), calc(v, r));
	if(lcheck == 1 || (lcheck == 0 && id < v)) udp(p << 1, l, mid, id);
	if(rcheck == 1 || (rcheck == 0 && id < v)) udp(p << 1 | 1, mid + 1, r, id);
}
void insert(int p, int l,int r,int ql,int qr, int id)
{
	if(ql <= l && r <= qr)
	{
		udp(p, l, r, id);
		return ;
	}
	int mid = (l + r) >> 1;
	if(ql <= mid) insert(p << 1, l, mid, ql, qr, id);
	if(qr > mid) insert(p << 1 | 1, mid + 1, r, ql, qr, id);
}
pair<double, int> pmax(pair<double, int> x, pair<double, int> y)
{
	int tmp = cmp(x.first, y.first);
	if(tmp == 0) return x.second < y.second ? x : y;
	return tmp > 0 ? x : y;
}
pair<double, int> query(int p, int l, int r, int x)
{
	if(l == r) 
	{
		return {calc(s[p], x), s[p]};
	}
	int mid = (l + r) >> 1;
	auto res = make_pair(calc(s[p], x),s[p]);
	if(x <= mid) res = pmax(res, query(p << 1 , l, mid, x));
	if(x > mid) res = pmax(res, query(p << 1 | 1, mid + 1, r, x));
	return res;
}

//插入线段
if(x0 > x1) swap(x0, x1), swap(y0, y1);
add(x0, y0, x1, y1);
insert(1, 1, p1, x0, x1, tot);
//询问
query(1, 1, p1, x)
```

```c++
struct Segment
{
	using Int = long long;

	int tot, n;
	struct func{
		Int k, b;
		func(Int k = 0, Int b = 0):k(k), b(b) {}
	}seg[N]; //线段
	
	vector<int> tag;
    
	Segment(int n = 0) {
		init(n);
	}
	void init(int _n)
	{
		n = _n;
		tot = 0;
		vector<int> tmp(4 * n + 10, 0);
		tag.swap(tmp);
	}
	void change(Int k, Int b, int ql, int qr)
	{
		seg[++tot] = {k, b};
		insert(1, 1, n, ql, qr, tot);
	} 
	Int calc(int id, Int x)
	{
		return seg[id].b + seg[id].k * x;
	}
	int cmp(Int x, Int y)
	{
		if(x == y) return 0;
		if(x > y) return 1;
		return -1;
	}

	void udp(int p, int l, int r, int id)
	{
		if(!tag[p])
		{
			tag[p] = id;
			return ;
		}
		int &v = tag[p], mid = (l + r) >> 1;
		int ckmid = cmp(calc(id, mid), calc(v, mid));
		if(ckmid == 1 || (ckmid == 0 && id < v)) swap(v,id);
		int lcheck = cmp(calc(id, l), calc(v, l)), rcheck = cmp(calc(id, r), calc(v, r));
		if(lcheck == 1 || (lcheck == 0 && id < v)) udp(p << 1, l, mid, id);
		if(rcheck == 1 || (rcheck == 0 && id < v)) udp(p << 1 | 1, mid + 1, r, id);
	}
	void insert(int p, int l, int r, int ql, int qr, int id) //插入线段斜率截距 
	{
		if(ql <= l && r <= qr)
		{
			udp(p, l, r, id);
			return ;
		}
		int mid = (l + r) >> 1;
		if(ql <= mid) insert(p << 1, l, mid, ql, qr, id);
		if(qr > mid) insert(p << 1 | 1, mid + 1, r, ql, qr, id);
	}
	struct node
	{
		Int val;
		int id;
		node(Int val = 0, int id = 0):val(val), id(id) {}
		bool operator<(const node &a) const
		{
			if(val != a.val) return val < a.val;
			return id < a.id;
		}
	};
	node query(int p, int l, int r, int x) 
	{
		if(!tag[p]) return node(-numeric_limits<long long>::max(), INF);
		node res(calc(tag[p], x), tag[p]);
		if(l == r)
		{
			return res;
		}
		int mid = (l + r) >> 1;
		if(x <= mid) res = max(res, query(p << 1, l, mid, x));
		if(x > mid) res = max(res, query(p << 1 | 1, mid + 1, r, x));
		return res;
	}
} t;
```



```c++
//动态开点
struct Segment
{
	
	typedef int Int;
	int tot, n, m;
	struct func{
		Int k, b;
		func(Int k = 0, Int b = 0):k(k), b(b) {}
	}seg[N]; //线段
	
	int tag[N << 5];
	int ls[N << 5], rs[N << 5];
	int rt, cnt;
    
	Segment(int n = 0, int m = 0) {
		init(n, m);
	}
	void init(int _n, int _m)
	{
		n = _n;
		m = _m;
		tot = 0;
		rt = 0;
		cnt = 0;
	}
	void change(Int k, Int b, int ql, int qr)
	{
		seg[++tot] = {k, b};
		insert(rt, 1, n, ql, qr, tot);
	} 
	Int calc(int id, int x)
	{
		return seg[id].b + seg[id].k * x;
	}
	int cmp(Int x, Int y)
	{
		if(x == y) return 0;
		if(x > y) return 1;
		return -1;
	}

	void udp(int &p, int l, int r, int id)
	{
		if(!p) 
		{
			p = ++cnt;
		}
		if(!tag[p])
		{
			tag[p] = id;
			return ;
		}
		int &v = tag[p], mid = (l + r) >> 1;
		int ckmid = cmp(calc(id, mid), calc(v, mid));
		if(ckmid == 1 || (ckmid == 0 && id < v)) swap(v,id);
		int lcheck = cmp(calc(id, l), calc(v, l)), rcheck = cmp(calc(id, r), calc(v, r));
		if(lcheck == 1 || (lcheck == 0 && id < v)) udp(ls[p], l, mid, id);
		if(rcheck == 1 || (rcheck == 0 && id < v)) udp(rs[p], mid + 1, r, id);
	}
	void insert(int &p, int l, int r, int ql, int qr, int id) //插入线段斜率截距 
	{
		if(!p) 
		{
			p = ++cnt;
		}
		if(ql <= l && r <= qr)
		{
			udp(p, l, r, id);
			return ;
		}
		int mid = (l + r) >> 1;
		if(ql <= mid) insert(ls[p], l, mid, ql, qr, id);
		if(qr > mid) insert(rs[p], mid + 1, r, ql, qr, id);
	}
	struct node
	{
		Int val;
		int id;
		node(Int val = 0, int id = 0):val(val), id(id) {}
		bool operator<(const node &a) const
		{
			if(val != a.val) return val < a.val;
			return id > a.id;
		}
	};
	node query(int p, int l, int r, int x) 
	{
		if(!p) return node(-LINF, -1);
		if(l == r)
		{
			return {calc(tag[p], x), tag[p]};
		}
		int mid = (l + r) >> 1;
		node res(calc(tag[p], x), tag[p]);
		
		if(x <= mid)
		{
			auto ts = query(ls[p], l, mid, x);
			if(res < ts) res = ts;
		}
		if(x > mid) res = max(res, query(rs[p], mid + 1, r, x));
		return res;
	}
} t;
```

