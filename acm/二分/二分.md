## 二分杂谈
在算法竞赛中，二分是最常见的算法。但是这并不意味着二分就很简单。二分最首要的就是观察到它的单调性。

### 二分基础
二分的本质是折半。

举一个简单例子，如何翻到书本第75页。那么我们可以先估计这个位置在哪里，然后打开书本，看看页码对不对，页码大就往前翻一下，小就往后翻一下。这是我们翻到具体页数所采用的方法。但是这个方法距离算法还是有一定差距的。首先，估计该再怎么估计，其次，往前往后应该翻多少才合适。这两个问题使得翻书的方法不具有普适性。但是这时候，我们可以每次翻中间的位置，这样就不需要估计也不需要考虑翻多少，每次我们都取中间值。

这样做之后，我们立刻发现翻书这个流程被规范化了，并且这种形式可以扩展到更多有趣的地方，比如奇怪函数的极值，零点等等。当然如果我们对求解的问题有更加深入的了解和更加严格的要求，我们也可以不取中间的值而是选择其他值，不过这部分内容会在进阶中提及。

为什么说二分的本质是折半，在1000页的书中，第一次我翻到500页，那么大于500页的部分我之后都不会去翻了。于是我可以选择的区间就变成了原先的一半，之后也是一样，每一步操作都是缩小了一半的区间。

当然，关于二分还有另外一种理解方式，我们将大于等于75的页码标记为$1$，其他页码标记为$0$，这样子我们就得到了一个形如 `0000...0111...11`的串。因此也可以说所有的二分都是在尝试找最开始的$1$的位置或者最后一个$0$的位置。

对于整数二分（即二分的都是整数，如果没有特殊说明，之后的二分都是指整数二分）来说，每次缩小一半，我只要让区间长度等于

$1$就行，二分次数就是$\lfloor \log_2 n \rfloor + 1 $​。这个计算结果也可以从第二种理解方式看出。

对于实数二分，二分次数取决于需要二分的精度。这不是这篇文章的重点。

### 二分形式
1000个人可以有1000钟写二分的方式，这里根据身边人的写法，总结出了以下几个大类。

#### 不记录答案

这个方法的本质是始终让$[l,r]$​这段区间有合法值。

常见写法如下

```c++
int l = 1, r = n + 1;
while(l < r)
{
    int mid = (l + r) >> 1;
    if(check(mid)) 
    {
        r = mid;
    }
    else
    {
        l = mid + 1;
    }
}
```

这时我们要找的是最左侧的$1$，那么找右侧的$0$，则有如下写法

```c++
int l = 0, r = n;
while(l < r)
{
    int mid = (l + r) >> 1;
    if(check(mid)) 
    {
        l = mid;
    }
    else
    {
        r = mid - 1;
    }
}
```

可以看到，在这个过程中，我们始终将合法的位置记录在$[l,r]$中。同时为了讨论方便，我们可以在序列的左侧补$0$，右侧补$1$。这样就能保证我们找这个序列时如果全$0$或者全$1$不会出现问题。

#### 记录答案

这个方法的本质是始终让$[l,r]$​这段区间未被确定。

```c++
int ans = -1;
int l = 1, r = n;
while(l <= r)
{
    int mid = (l + r) >> 1;
    if(check(mid))
    {
        ans = mid;
        r = mid - 1;
	}
    else 
    {
        l = mid + 1;
	}
}
```

找$0$同理，这里不单独列出。

#### 二分边界

这个方法的本质是始终让$l$指向0，而$r$​指向1。

这种方法在一些人看来更加接近二分的本质，也有很多人习惯使用这种写法。

```c++
int l = 0, r = n + 1;
while(r - l > 1)
{
    int mid = (l + r) >> 1;
    if(check(mid))
    {
        r = mid;
	}
    else 
    {
        l = mid;
	}
}
```

以上三种写法大同小异，区别在于$[l,r]$的含义。

#### 倍增

这个方式的本质是试图直接确定形式串`0000...0111...11`中最右的$0$的位置。

```c++
int ans = 0;
for(int i = 30; i >= 0; --i)
{
    if(!check(ans + (1 << i))) ans += 1 << i;
}
```

这种写法的本质是直接确定位置，而位置是一个数，把这个数考虑成二进制，从高到低确定每一位的值。

#### 小结

这几种二分形式都是比较常见的，其他还有很多细微的变形比如上取整，或者其他。

另外需要注意的是，在$c++$中尽量使用$>>$进行取整，整数类型的$/$是向$0$取整。尽管大部分时候都可以忽略这一点，也可以调整写法例如改成$l + (r - l) / 2$来规避这个问题。这种写法也可以在特殊场合下规避整形溢出的问题。

对于新手而言，在不清楚二分本质的情况下，使用记录答案法较好，该方法虽然需要额外定义一个变量，但是本身代码比较清楚直观，$l$和$r$不用考虑向那边偏移，而不记录答案法需要。对比于二分边界法，则省去了额外的考虑，只需要用$ans$进行输入而不需要分辨$l$和$r$​用哪个。而倍增法对于初学者来说容易造成理解上的误区。

以上二分的形式对于大部分人来说就类似于“茴”的几种写法，但是由于代码填空题这种题目的存在

### 二分的选择

如果我们选择一个点，那么这个点就将区间划分为两个部分，不妨记为$n_L$，$n_R$，那么减少的区间长度期望是$\frac{n_L}{n_L+n_R} * n_R + \frac{n_R}{n_L+n_R} * n_L$，显然$n_L+n_R$是定值，因此$n_L$，$n_R$相差不超过$1$就可以取最大值。

如果我们选择多个点，分别记每一段区间为$n_1, n_2,n_3, \cdots, n_k$，那么最后留下的区间为$\sum_j \frac{n_j}{\sum_i n_i} * n_j$，由柯西不等式易知也是在区间长度极差不超过$1$时留下的区间最小。找零点最后剩下的可以保留相邻的异号的两个点，那么实际可以留下的区间为$\frac{1}{k}$，操作次数为$k - 1$，实际总操作次数为$(k - 1) * \log_k n $，即$\frac{k - 1}{\log_2 k} \log_2 n$，那么易知$k$越小越好。

### 三分

三分要求函数是单峰函数或者单谷函数，并且极值点两侧严格单调。



### 二分进阶

